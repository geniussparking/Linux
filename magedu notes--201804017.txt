Day 1

VNC: Virtual Network Computing  协议 远程桌面分享工具，C/S，服务端和客户端；

如何获取老师讲课的课件，文档，学习资料，课堂笔记，ftp://172.16.0.1  ftp server


Linux运维课程体系大纲
	就业班（基础）
	架构师班（高级）

	Linux入门（第一阶段）
	Linux系统管理
	Linux服务及安全管理
		httpd, lamp, lnmp
		Cache: memchached, varnish
		DB: mysql (mariadb)
	Linux Cluster:
		LB Cluster: Nginx, LVS
		HA Cluster: Keepalived
	Linux Ops: ansible
	Monitoring: zabbix
	shell脚本编程
	
	http:（第二阶段）
		tomcat, lnmt, lamt, session replication cluster
		分布式存储系统
			MogileFS, GlusterFS
		LB Cluster: haproxy
		HA Cluster: Corosync+Pacemaker, pcs/crmsh
		MySQL: HA Cluster  MHA  备份恢复工具使用 MySQL Replcation Read-Write splitting
		NoSQL: redis, mongodb, HBase
		运维工具：puppet目前比较成熟完整的自动化工具 [saltstack不成熟], cobbler
		虚拟化：
			Linux操作系统原理，虚拟化技术原理；
			kvm虚拟化应用详解
			xen虚拟化已经快被淘汰
			虚拟化网络：比较复杂，纯软件虚拟路由器，交换机... SDN：软件定义的网络
			OpenStack:云栈
		Docker: 容器
		Docker云
		ELK Stack: 日志分析工具 --> ElasticSearch: 搜索任何文件 Logstash 日志搜集工具，Kibana: 日志展示工具
		大数据：Hadoop v2, 并行存储及分析平台
			HBase, Hive
			Storm, Spark
		系统优化
		Python编程
			
	RedHat: 红帽认证考试
		RHCSA
		RHCE
		RHCA
				
	IT技术领域
		研发：
			硬件：接口
				CPU(运算器和控制器）,内存，输入输出设备 
					冯诺依曼体系
				机器语言：二进制指令，二进制数据（最底层）
				
			软件：
				汇编语言：用人类的自然语言在表述机器语言，低级语言,汇编器，写驱动程序
				高级语言：编译器
					系统级：C, C++ 开发操作系统，性能要求较高的项目：MySQL Oracle等等，成才很难
					应用级：Java, Python， Ruby 离人近，离机器远,写应用程序
				程序员写的程序代码，编程语言（低级和高级）
		应用：
			Linux运维,用别人写好的应用程序
				shell脚本编程：让某些应用工作能自动完成
				Python：专业编程语言--> ansible openstack
			
			DevOps:
				Development
				Operation
			
			
	计算机与操作系统
		ENIARC(最早）：
			CPU: 运算器，控制器，寄存器（存储器），缓存（123级缓存），寄存和缓存是用老加速的；
				CPU自己会有一些指令集，例如有加减乘除等功能；指令集：特权指令，普通指令
				CPU内部的缓存越大，价格越高，缓存为王，缓存高一倍，价格可能高的离谱
			存储器：内存，RAM（Random Access Memory，随机存储器）
				一个Cell: 8bits位 -->1Bytes字节 最小存储单元，
			Input：下指令，提供数据等
			Output：输出数据加工后的结果
		程序：指令+数据
			  算法+数据结构（数据包大小，结构等）
		
		过程式编程语言：
			顺序执行：执行一遍整个指令
			循环执行：将整个循环执行N次
			选择执行：仅执行其中一个分支
		
		多任务：multi tasks
			起初不能多任务，后来加入监控程序，用来调配
			内存通过空间去划分多个
			CPU通过时间划分
			Bell实验室，MIT麻省理工，GE通用电气--> 他们写了一个监控程序Multics
			
			Bell的Ken Thompson: Space Travel游戏--> 
			DEC: PDP-11小型机，VAX（VMS）
			1969年前后Ken在PDP-7上写程序：汇编语言---> Unics --> 改名成Unix，设计没有硬伤，很精良
			Unix 1971年，Bell实验室要为自己进行文字处理，写了nroff，对Unix不断进行改进
			1972年，Unix的装机量在Bell达到10台
			最开始是B语言写的，是解释型语言，汇编语言，与底层结合太紧密；
			B：Dennis Ritch 把B语言改成了C语言
			1973年，Ken和Dennis一起用C语言重写整个Unix，C语言与cpu没有关系，只有汇编器（编译器）与CPU有关系，编译器将底层CPU的不同指令抹平了
			使用C语言改写Unix后，是要编译器支持，使得Unix可以装在任何机器上；
			1979年证实，把Unix改用C语言写是成功的；
			当时的Bell实验室属于AT&T，当时AT&T在被反垄断诉讼，不能销售任何电话电报相关的产品，只能无偿提供；
			当时很多大学机构免费获取了Unix，使得Unix可以被研究改进，然后反馈给了Bell实验室；
			1979年，AT&T:System V7
			1978年，SCO包装发行商用Unix
			1980年：Microsoft, 售卖UNIX的变种XENIX
			Berkeley: Ken,Berkeley去任教，使得Berkeley走在前沿
				Bill Joy, BSRG, 1977, BSD(Berkeley System Distribution)
			1980年，DARPA国防部高级研究署  TCP/IP，DARPA将TCP/IP的合同给了Berkeley
			1983年，TCP/IP协议诞生在了Unix系统上
			1981年，Microsoft，Bill Gates
				当时西雅图的SCP的程序员研发了QDOS（Quick and Dirty Operating System），当时UNIX跑在摩托罗拉的CPU上
				第一代的pc兼容机是由intel生产的CPU，性能太差，跑不了UNIX
				Bill 5万美元直接买断了QDOS的授权，然后进行了修补，后来通过他母亲在IBM懂事会的身份拿到了IBM PC兼容机的订单
				Bill只卖授权，每台PC兼容机给Bill授权费，Bill赚到上亿身价；
			DOS 2.0, 光芒胜过CP/M，直到1990年，微软开发DOS都是用的Unix
			SUN: Bill Joy，卖工作站workstation
			APPLE诞生，卖PC机
				XEROX: PARK（star图形操作系统）还发明了以太网和鼠标，将专利免费提供给社会
				乔布斯买到了star，Bill从乔布斯也拿到了star，回去就在dos上研究开发图形界面系统，
				Bill赶在乔布斯前面卖给了乔布斯的生意伙伴，并且发布了windows
				Bill拉拢了VMS的一伙人开发改进windows--> windows NT（new technology）
			System V Unix 和BSD打官司，UNIX在这10年因为打官司没落了，微软成长起来；
			1985年：Richard Stallman，GNU运动，GNU is not Unix，is free; GPL: Genreal Public License；FSF：free software foundation
				任何软件只要遵守GPL协定，那就是free的，自由的，可以获取源代码的；
				X-Window加入GPL，为unix做图形界面
				gcc: gnu c complier
				vi: visual interface
				... ...
				
			
			
			商业版UNIX：自己加功能，不公布阻碍发展
				SUN: Solaris
				IBM: AIX
				HP: HP-UX
				
			Andrew: Minix, 4000行的unix
			
			1990： BSD 将System V的代码慢慢移除？
					Jolitz,尝试将BSD移植到x86上，后来因为反对商业化，将研究成果全部删除；
					1992年386-BSD继续
			1991年8月：Linus Torvalds宣布成立Linux    GPL
			
			Larry Wall, patch工具，可以部分修改代码
			上面说的所有的系统（BSD,Linux,Minix,System v），其实都是Kernel,不包括应用程序，kernel包含控制器和驱动等等
			完整的OS: Kernel+Application
			狭义OS: Kernel
			
			Linus提供Kernel, GNU提供application --> GNU/Linux
			Mac BSD系统
			Andriod Linux
			
			os接口有两类：接口也是应用程序
				GUI：Graphic User Interface
						GNome:C语言开发，研发环境gtk
						KDE: c++, qt
				CLI: Command Line Interface
					bash
					zsh
					csh
					tcsh
					ksh
			操作系统的功能：
				驱动程序
				进程管理
				安全
				网络功能
				内存管理
				文件系统
				........
				
			API: Application Program Interface  程序员面对的编程接口
			ABI: Application Binary Interface 	程序应用者面对的运行程序接口
			
			硬件--操作系统，驱动--库  编程的时候可以进行系统调用system call，也可以调用库Library, 
			如果不同的操作系统提供的Library调用接口一样，那开发出来的应用程序就可以通用
			POSIX: Portable Operation System 可移植操作系统
			
			GNU:
				提供源码：需要编译成二进制格式才能在操作系统上运行
				Linux是所有志愿者把不同部分的源码编译成二进制文件后才能使用的
				发行版：数百种，不同组织对源码进行编译的时候的理解是不同的，所以有不同的特性和版本
				主流发行版本：
				Debian：Ubuntu是基于debian的二次发行版本
							mint 桌面做的很好
						Knopix 以安全著称
				Slackware--S.U.S.E
							SLES：suse linux enterprise system
							openSUSE
				RedHat：
					--Centos基于红帽企业版的二次发行,CentOS和RHEL是完全兼容的，CentOS是由红帽提供的源码，社区编译再发行出来的系统
					RedHat 9.0
							--RedHat Enterprise Linux: RHEL
								--CentOS: Community Enterprise OS
				
				RedHat CentOS 各个Linux的发行版本和Linux的关系：Linux是由GNU组织提供应用，使用Linux内核的操作系统，但是GNU组织只提供源码，
				源码还需要编译成系统才能使用，所有的发行版本都是不同的组织编译出来的；
				
		软件程序：版本号
				major, minor, release
				Linux: 0.99, 2.2, 2.4, 2.6, 3.0, 4.0 Linux内核官网：www.kernel.org 
		发行版本也有自己的版本号：
			REHL:5.x 6.x 7.x 	
				Fedora 23
			Debian: 8.x 
			OpenSuSE: 13.x 
		作业：开源协定相关
			GPL, BSD, Apache
			Android
		
回顾：
	Debian, Slackware, RedHat
		Debian:
			Ubuntu
			Knopix 
		Slackware:
			S.u.S.E 
				OenSUSE
		RedHat:
			Fedora
			CentOS
	
	Linux: 
		Linux仅仅是内核 + GNU组织各种Application = 完整操作系统
		GNU/Linux: 通常以源码（文本格式）方式提供
					自由、灵活
		编码：文本格式的源码使用编译器将源码编译成对应的机器能运行的程序	
		GNU组织下的开源协定：GPL 流毒无穷
		BSD也是开源协定，比较宽松
	Linux基础：CPU架构
		x86 兼容CPU
		x64(通常叫AMD64，64架构是最先由AMD研发的)
		m68000 -- m68k 摩托罗拉cpu
		arm架构 常用手持移动设备的cpu
		sparc 斯坦福大学研发
		power IBM的很强悍的CPU，全球第一款双核 四核 64核，第一款主频超过4GHZ的CPU
		powerpc简装版power cpu, 由苹果，IBM，摩托罗拉合起来研发，早期苹果工作站都是power cpu
		MIPS 
		HP的Alpha 跑hp-ux 
	指令集：复杂指令集 精简指令集
	
	硬件：机器语言，对程序员来说太难了
	所以，厂商生产完硬件，提供微码编程接口--汇编语言，汇编程序员调用汇编语言接口来写程序，写好的程序需要一个汇编器转换成机器语言才能在硬件上执行
	使用汇编语言写的任何操作系统都是直接在硬件上运行的，所以那时候写的操作系统很难移植
	后来出现了POSIX规范，统一标准，可移植操作系统
	后来出现高级语言（c,c++）写操作系统，和cpu没有密切关系了，这种高级语言需要先编译成对应的cpu能执行的机器语言
	编译的过程：可以针对正在运行的CPU架构编译，也可以交叉编译（cross compile），可以运行在别的CPU架构上, 实现了代码的移植
	注：编译完成的机器语言就不能再移植
	
	Stallman: GNU运动
	开源协定：GNU的GPL，General Public License, 流毒无穷，只要沾边GPL的代码，所有代码成GPL的版权，后来阻碍GPL运动开展；
				后来产生LGPL：Lesser GPL, 更宽松的GPL-- 调用了GPL的库，不用开源，但是还是不够自由，现在GPL V2 V3
			下面两个是比较宽松的协定：可以拿来修改后包装成商业版本，只要不说是BSD或Apache协定的代码就行
			相当于说代码可以随意借用和修改，很自由，全凭自由，更加符合自由软件精神
			BSD开源协定：
			Apache开源协定：ASF -- Apache Software Foundation,非常流行, 风头正盛
			Apache和BSD极大的促进了开源运动
			
	双线授权：
		遵循开源协定的源码，社区版本，任何人都可以拿去使用
		商业授权版本，卖增值服务和额外功能---企业版
	
	程序管理：
		程序的组成部分：	
			二进制程序：一个程序能运行的内容
			配置文件：通常是文本文件，XML文件
			库文件
			帮助文件
		程序包管理器：
			程序的组成文件打包成一个或有限几个文件
			完成安装操作
			完成卸载操作
			查询功能
		Debian：dpkg/deb, apt-get(前端管理器)
		RedHat: rpm, yum, yum的升级版 --> dnf
		S.u.S.E: rpm, zypper
		ArchLinux: port 
		Gentoo: 需要边安装边编译的，最适合机器的环境，性能上好很多
		LFS: Linux From Scratch Linux从零开始构建， 需要自己下载源码，自己编译的Linux，最纯净的Linux, 能了解整个Linux的各个部分，完完全全的了解Linux
		Kali: 内置各种渗透工具的Linux
	安装Linux:
		虚拟机方式：使用软件虚拟化各个硬件
			计算机：CPU 内存 IO 
				CPU 网卡：时序复用 
				内存 硬盘：空间复用 
				IO鼠标键盘显示器：捕获焦点 
		虚拟化软件程序：
			vmware workstation
			virtualbox
	
	CentOS 7 操作:
		设置语言环境：localectl list-locales 查看有哪些语言可以设置
					设置成中文的：localectl set-locale LANG=zh_CN.uft8
					设置回英文：localectl set-locale LANG=en_US.utf8
	终端：terminal
		用户界面：
			GUI:
				GNome
				KDE
			CLI:
				bash zsh sh csh tcsh ksh
	远程连接：
		查看ssh协议是否开启: ~]# ss -tnl, 查看系统是否监听于tcp协议的22号端口
		~]# ifconfig 查看ip, 或者使用命令 ip addr list, 找到inet开头的，找到IP地址
		确保防火墙处于关闭状态
			1. iptables -L -n 
			2. iptables -F 
			CentOS 7:
				systemctl diable firewalld.service  关掉当前的防火墙
				systemctl stop firewalld.service	永久关闭防火墙
			CentOS 6:
				service iptables stop
				chkconfig iptables off
	常用命令：
		echo $SHELL 查看当前所用shell类型
	终端设备：terminal
			多任务 多用户
			物理终端，控制台：console
			虚拟终端：默认6个，使用ctrl+alt+F(1-6)进行切换，相当于多用户登录,然后startx启动图形终端
			图形终端：CentOS 6: ctrl+alt+F7  直接进入图形终端
			串行终端：ttyS
			伪终端：pty 用ssh远程连接的界面，图形界面的terminal
	Linux的哲学思想之一：一切皆文件
			表现之一：硬件设备也通过文件表示
				物理终端：/dev/console
				虚拟终端：/dev/tty+数字[1,6]  /dev/tty#   #表示数字    
				串行终端：/dev/ttyS#
				伪终端：/dev/pts/# 
			使用tty命令就可以查看当前终端号，在系统里面使用terminal的时候会输出：/dev/tty#   用ssh连接后会输出/dev/pts/#
				
	注意：在启动设备之后，在其上关联一个用户接口程序，即可实现与用户交互
			查看终端设备：tty
			查看接口程序：echo $SHELL
			启动GUI： 虚拟终端接口：startx &
	
	CLI: 命令行接口，prompt 
			[root@localhost ~]# COMMAND 
				prompt:
					root: 当前登录用户
					localhost:当前主机的主机名，非完整格式
					~： 用户当前所在的目录(current directory), 也称为工作目录(working directory): 相对路径
					#：命令提示符：
						#: 管理员账号：拥有最高权限，能执行所有操作
						$: 非root用户，普通用户，只拥有系统使用权限，不能执行系统管理操作，最好只用非管理账号登录，执行管理操作临时切换成管理账户，操作完，切换回来非管理账户
								添加用户: useradd centos
								切换用户: su - centos
								然后显示：[centos@localhost ~]$ 
	总结几个命令：
		tty 查看当前终端设备
		ifconfig 或 ip addr list
		echo $SHELL 查看当前shell类型  echo 回显
		ping 网络探测的回显请求，探测目标主机与当前主机之间的连通性
		ctrl+c 终止ping, 也可以在命令输到一半，不想执行了，可以使用ctrl+c 
		systemctl poweroff 关机
		poweroff 也可以关机
		halt 关机
		systemctl reboot 重启, 也可以直接用reboot
		iptalbles -L -n 
		systemctl disable firewalld.service 关掉当前的防火墙
		systemctl stop firewalld.service 永久关闭防火墙
	
	Linux的哲学思想：
		1. 一切皆文件，几乎将所有资源统统抽象成文件形式： 包括硬件设备，甚至通信借口等；那么访问文件就只需要一个接口：
				open() read() write() close() delete() create()
		2. 由众多功能单一的程序组成：一个程序通常只做好一件事；组合小程序完成复杂任务；
		3. 程序启动后尽量避免跟用户交互，目标：易于以编程方式实现自动化任务
		4. 使用文本文件保存配置信息
	思考：文件是什么？众多文件如何有效组织？分类机制：根--二级位置--三级位置
		目录：路径映射  /dev/pts/2
		文件：存储空间存储的一段流式数据，对数据可以做到按名存取；
		文件系统：层级结构：有索引
			/: 根 原初起点 根目录
				第二层结构
				第三层结构
			--> 倒置树状结构
			文件路径表示：
				绝对路径：从根开始表示出的路径
				相对路径：从当前位置开始表示的路径
			文件名使用法则：
				严格区分字符大小写，windows不区分
				目录也是文件，在同一路径下，两文件不能同名
				支持使用除了/以外的任意字符
				最长不能超过255个字符
				每个用户在系统上都有个home目录，别人不能随便进来的
				工作目录：
					/etc/sysconfig/network-scripts/ifcfg-eno16777736
					basename: ifcfg-eno16777736
					dirname: /etc/sysconfig/network-scripts
				命令：~]# basename /PATH/TO/SOMEFILE
							SOMEFILE
					  ~]# dirname /PATH/TO/SOMEFILE
							/PATH/TO
				
	回顾：
		开源协定：GPL LGPL BSD Apache
		BSD:
			1. 如果二次发布的产品中包含源代码，则在源代码中必须带有原来的代码中的BSD协定；
			2. 如果二次发布产品是二进制格式的库或程序，则需要在发布的文档或版权声明中说明包含原来的代码中的BSD协议；
			3. 不可以用开源代码的作者或组织，以及原来的产品的名字做市场推广；
		开源：代码的共产主义运动
		
		文件系统，文件，目录
			倒置树状结构
				目录
				文件
			文件名：严格区分大小写，路径分隔符：/
			文件名以.开头的表示隐藏文件
		路径：
			绝对，相对
		程序的组成部分：
			二进制程序文件、库文件--> 可执行文件，只能通过16进制查看器查看
				二进制文件能被独立执行
				库文件不能被独立执行，只能被调用时执行
			配置文件、帮助文件--> 可被查看其内容的文件
		《穿越计算机的迷雾》《量子物理史话》
		
		人机交互界面：
			GUI
			CLI
		命令通用格式：
			COMMAND OPTIONS ARGUMENTS  命令 选项 参数，
				COMMAND:
					命令的作用：发起一个命令（请求内核将某个二进制程序运行为一个进程），程序-->进程 静态-->动态（有生命周期）
					命令本身是一个可执行的程序文件；二进制格式的文件，有可能会调用库文件；
						多数程序文件都存放在四个目录：/bin, /sbin(管理员才能执行的)，/usr/bin, /usr/sbin
						安装一些应用之后，有些程序文件可能会放在：/usr/local/bin, /usr/local/sbin
						普通命令：/bin/, /usr/bin, /usr/local/bin
						管理命令：/sbin/,/usr/sbin, /usr/local/sbin
						共享库：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64
							32bits的库：/lib, /usr/lib, /usr/local/lib
							64bits的库：/lib64, /usr/lib64, /usr/local/lib64
						注意：并非所有的命令都有一个在其目录与之对应的可执行程序文件
					命令必须遵循特定格式规范：
						Windows: exe msi
						Linux: ELF, 使用file命令： file /bin/ls 可以查看bin目录下，ls这个文件的内容格式的类型
					命令分为两类：
						由shell程序的自带的命令：内置命令（builtin）
						独立的可执行程序文件，文件名即命令名；外部命令
					shell程序是独特的程序，负责解析用户提供的命令，shell通过环境变量来定义工作特性，跟DOS一样的原理，要加入环境变量就可以直接运行，例如ls
						环境变量：
							PATH: 从哪些路径中查找用户键入的命令字符换对应的命令文件
							当前系统的环境变量：echo $PATH
								[root@localhost ~]# echo $PATH
								/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
								查找顺序：自左向右
						shell自带的命令是没有外部程序文件的，是在环境变量指定的路径里面找不到的
						查看命令类型(内部命令/外部命令)：type COMMAND 
						[root@localhost ~]# type ls
						ls is aliased to `ls --color=auto'   外部命令
						[root@localhost ~]# type type
						type is a shell builtin		shell内部命令
						如果把环境变量全部删除，那么就没有外部命令可执行了，只能通过绝对路径才能执行；只有shell内部命令能执行；
				OPTION:
					作用：指定命令的运行特性，或者调整命令运行时所要执行的代码和实现的功能
					选项有两种表现形式：
						短选项：-c, 例如：-l， -d，
								注意：有些命令的选项没有-
								如果同一命令使用多个短选项，多数可以合并
									例如：ls -l -d /var 
										  ls -ld /var 效果一样
						长选项：--word, 例如：--help, --human-readable
								注意：长选项不能合并
						注意：有些选项可以带参数，此称为选项参数，而不要称为命令参数
				ARGUMENTS:
					命令的作用对象：命令对什么生效
					注意：不同命令的参数：有些命令可同时带多个参数，多个之间用空白字符分割
					例如：ls -ld /var 这里的var是作用对象
			获取命令的使用帮助：
				内部命令：help COMMAND
				外部命令：
					(1).命令自带简要格式的使用帮助
						# COMMAND --help
					(2).使用手册：manual, 系统必须有这个手册，手册文件通常位于：/usr/share/man
						# man COMMAND
							SECTION:
								NAME 功能性说明
								SYNOPSIS 语法格式
								DESCRIPTION 描述
								OPTIONS 选项
								EXAMPLES 示例
								AUTHOR 作者
								BUGS 报告bug的方式
								SEE ALSO 参考
									
									SYNOPSIS: 看懂语法规则
										[] 可选参考
										<> 必选
										a|b|c 多选一
										... 同内容可出现多个
							使用手册还分为章节
								压缩格式的文件，有章节之分 /usr/share/man man1 man2 ... 
								man1: 用户命令，普通用户和管理员都可以使用的命令
								man2: 系统调用的，程序员才会用
								man3: c库调用
								man4: 设备文件及特殊文件
								man5: 文件格式，文件配置格式的说明
								man6: 游戏的使用帮助
								man7: 杂项
								man8: 管理工具及守护进程
							有些命令不止在一个man的章节存在，例如：man passwd 系统默认会到第一章节去找，在页面的最上面会出现PASSWD(1)表示第一章节
								如果想专门查看第五章节：命令这样写：man 5 passwd 即可，页面最上面会输出：PASSWD(5) 
							注意：并非每个COMMAND在所有章节下都有手册
							如何知道一个命令在哪些章节有手册：whatis COMMAND
									[root@localhost ~]# whatis passwd
									sslpasswd (1ssl)     - compute password hashes
									passwd (1)           - update user's authentication tokens
									passwd (5)           - password file
								whatis的执行过程是查询数据库进行的，手动更新数据库：make whatis
								man命令打开手册以后的操作方法：
									翻屏：空格键向文件尾部翻屏
									b: 向文件首部翻屏
									ctrl+d: 向文件尾部翻办屏
									ctrl+u: 向文件首部翻半屏
									回车键：一次向文件尾部翻一行
									k: 向文件首部翻一行
									G：跳转至最后一行
									#G：跳转至指定行，1G：跳转至首部
								文本搜索功能：
									/keyword  从文件首部向文件尾部依次查找
									?keyword  从文件尾部向文件首部依次查找
										n：找到结果后表示下一个
										N：上一个
									查找时不区分大小写
								q：退出
							选项：man -M /PATH/TO/SOMEWHERE 到指定目录下查找命令手册并打开
							练习：useradd命令的用法
								1. 添加用户gentoo
									useradd gentoo
								2. 添加用户slackware,要求指定其所用的shell为/bin/tcsh
									useradd -s /bin/tcsh slackware
									tail -1 /etc/passwd 查看shell类型
							id命令：查看所有用户
					(3) info COMMAND
						获取命令的在线文档
					(4) 很多应用程序会自带帮助文档： /usr/share/doc/APP-VERSION
						README: 程序的相关信息
						INSTALL:安装帮助
						CHANGES:版本迭代详细信息
					(5) 主流发行版官方文档
						http://www.readhat.com/doc
					(6) 程序的官方文档---官方会提供Documentation
					(7) 搜索引擎
						 keyword filetype:pdf
						 keyword site:...
					书籍的出版社：O'Reilly Wrox 机械工业 电子工业 人民邮电 清华大学 水利水电出版社
								
			Linux文件系统：
				1. 文件名名称严格区分大小写
				2. 文件可以使用除/以外的任意字符
				3. 文件名长度不能超过255个字符
				4. 以.开头的文件为隐藏文件
					. : 当前目录
					.. : 当前目录上一级目录
			工作目录： working directory
			家目录： home
			常用命令：
				pwd: printing working directory, 显示当前工作目录
				cd: change directory
					cd [/PATH/TO/SOMEWHERE]
					cd: 不带参数默认切换回home
						注意：bash中~表示家目录
						cd ~: 切换回自己的家目录
						cd ~USERNAME: 切换到指定用户的家目录
						cd -: 上一个目录和当前目录来回切换
						cd ...: 回到上级目录
						echo $PWD	输出当前工作目录
						echo $OLDPWD  输出上一次的工作目录,两个bash的环境变量，是不断在改变的
						cd $OLDPWD 相当于 cd -
				ls: list 列出指定目录下的内容
					ls [OPTION]... [FILE]...
					ls -a: 列出全部内容，包括隐藏文件
					ls -A: 显示除.和..之外的所有文件
					ls -a /var/: 显示文件夹/var/的内容
					ls -l: --long 长格式列表，即显示文件的详细属性信息
						-rw-r--r--.  1 root root     1441 Nov  9 09:28 initial-setup-ks.cfg
						-：文件类型 -,d,b,c,l,s,p, 都是表示文件类型
						rw-r--r--：三组 
							rw-：左三位表示文件属主的权限
							r--：中三位表示文件属组的权限
							r--：右三位表示其他用户（非属主、属组）的权限
						1：数字表示文件被硬链接的次数
						root: 文件的属性
						root: 文件的属组
						1441：数字表示文件的大小，单位是字节
						Nov  9 09:28：文件最后一次被修改的时间
						initial-setup-ks.cfg：文件名
					ls -l -h， --human-readable: 对文件大小换算，非精确		
					ls -lh 选项部分合并写	
					ls -ld : 看文件夹自身的属性，不是这个文件夹里面的内容， ld要结合起来使用
							[root@localhost ~]# ls -ld Music
							drwxr-xr-x. 2 root root 6 Nov 29 06:44 Music
					ls -r: 逆序显示 ls -lr 逆序显示详细信息
					ls -R: recursive 递归显示
				cat: concatenate files and print on the standard output
						连接文件并将文件以标准形式显示出来，是文本文件显示工具，不要用于二进制文件
					[root@localhost /]# file /etc/fstab    查看文件类型
					/etc/fstab: ASCII text
					cat /etc/fstab /etc/issue 同时显示多个文件，连接显示
					cat -n /etc/fstab  输出的文件内容编号
					cat -E /etc/fstab  在每行结尾显示$
				tac: 也是文本文件查看工具，文件内容是逆序（行）显示
				file: 查看文件内容的类型
					大多数选项不怎么使用
				echo:回显
					echo [SHORT-OPTION]... [STRING]...
						-n：不进行换行
							例如：[root@localhost ~]# echo "hello"
									hello
									[root@localhost ~]# echo -n "hello"
									hello[root@localhost ~]#    这里没有换行
						-e: 让转义符生效
						[root@localhost ~]# echo -e "hello \nworld"    换行符\n生效
							hello 
							world
						[root@localhost ~]#
						STRING可以使用引号，单引号和双引号均可用
							单引号：强引用，变量不执行替换，不起作用
							双引号：弱引用，变量会替换
								[root@localhost ~]# echo "$SHELL"
								/bin/bash
								[root@localhost ~]# echo '$SHELL'
								$SHELL
							注意：变量引用的正规符号：${SHELL},但是{}可以省略
				关机或重启命令：
					shutdown
						 shutdown [OPTIONS...] [TIME] [WALL...]
							OPTIONS:
								-h: halt
								-r: restart
								-c: cancel
							TIME:
								now  立刻关机
								hh:mm  几点几分
								+m  几分钟之后
					wall: 发广播给登录系统的其他用户
						wall "i'm gonna shutdown the machine"
					shutdown -h +5  当管理员执行了5分钟后关机命令后，系统会自动wall给所有登录的用户，提醒将会5分钟后关机
					shutdown -c 取消关机
					[root@localhost ~]# shutdown -r +10 "hello, the system is going to restart after 10 minus, thanks a lot."
						可以在shutdown命令后面加上wall的命令
				日期相关命令：
					date:
						显示时间：date [OPTION]... [+FORMAT] 
							[root@localhost ~]# date +%F   后面的+%F是格式化字符串
							2018-01-17
							[root@localhost ~]# date +"%F %T"  注意，这里要用双引号引起来，告诉解释器这里是一个字符串
							2018-01-17 07:22:16
							[root@localhost ~]# date +%s   显示时间戳 unix元年，unix诞生日 1970.01.01 00:00:00
							1516191891
						设置时间：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]  
							date 080808082015.12  把时间设置成: 2015年8月8日8时8分12秒
					clock/hwclock, 两个命令是一个 hwclock 硬件时钟
						[root@localhost ~]# which clock     查找clock命令在哪里
						/usr/sbin/clock
						[root@localhost ~]# which hwclock
						/usr/sbin/hwclock
						[root@localhost ~]# file /usr/sbin/clock		
						/usr/sbin/clock: symbolic link to `hwclock'		clock是hwclock的一个软链接

						hwclock - query or set the hardware clock (RTC)
						Linux启动后有两套时钟，启动时会从硬件读取时间，启动完了就不再与硬件相关
						date命令看到的是系统时钟
							-s, --hctosys
								Set the System Time from the Hardware Clock.
							-w, --systohc
								Set the Hardware Clock to the current System Time.
					cal: - display a calendar
						cal 2018显示2018年的日历
						cal 10 2018 显示2018年10月的
						cal 01 01 2018 显示2018年1月1日的
				课外作业：
					which - shows the full path of (shell) commands.
					whereis - locate the binary, source, and manual page files for a command
					who - show who is logged on
						-a, --all
							same as -b -d --login -p -r -t -T -u
						-b, --boot
							time of last system boot
					w - Show who is logged on and what they are doing.
						 w [options] user [...]
						 
				如何使用man
					whatis keyword
					man # keyword
						SECTION:
							NAME
							SYNOPSIS:
								[]可省略的内容
								<>必须提供
								|多选一
								{}分组的，不是必须的
								...可以出现多次的
							man快捷键：按h看帮助
								Space 后翻页
								b 前翻页
								Enter 后翻一行
								k 前翻一页
								Ctrl+d 后翻半页
								Ctrl+u 前翻半页
								q 退出
								#G 跳至某行 1G跳至第一行 G跳至最后一行
								/keyword 搜索
								?keyword 搜索
									n 下一个
									N 上一个
				基础命令：
					pwd cd ls echo date clock hwclocl cal cat tac file type tty shutdown reboot halt poweroff
		
		
		Linux文件系统：
			硬件--内核--系统调用--壳shell--库函数--应用程序（通过系统调用，库函数开发）
			Linux程序的编译方式: 通用的系统库，Glibc库--GNU的标准C库，是Linux操作系统上必须提供的一个最基本的库，市面上的应用程序或多或少的调用了这个库中的函数/模块
			动态链接式编译：库文件是事先存在系统中的（Linux而言是Glibc），程序运行时，操作系统中要有调用的库文件才能正确运行
			静态编译：把所依赖/调用的库直接复制到程序中，一起打包，这样程序会更加通用，但是程序会很大，对系统资源是个负担，
				相当于要在内存中多开辟空间，动态链接式是共享库，内存中只需要载入一份
			
			进程的类型：
				终端：硬件设备，关联一个用户接口，例如远程连接管理，只要用户使用交互式接口启动的都叫与终端相关
				与终端相关：通过终端启动
				与终端无关：操作系统引导启动过程中自动启动
			操作系统的组成：
				静态：kernel, application（库也是application）
				文件系统：组织成层级结构，方便查找文件
					应用程序组成：二进制 库 配置 帮助
				任何时候使用操作系统都是在操作系统文件树里面切换working directory
					Windows的磁盘分区概念不同,windows下可以随意访问某个磁盘下的任意文件
					Linux下，所有文件必须从根开始，服从根的管理和分配，有层级结构划分；
							新的分区，必须挂载mount在根的下面，被根管理；例如一个U盘要连接，系统必须把这个U盘挂载在（任意）一个空目录下，这个空目录就是挂载点，一般挂载在/Media下
							FHS: Filesystem Hierarchy Standard 文件系统层级结构标准，所有Linux发行版必须遵循这个文件系统标准
								必须了解每一个目录的意义：这样就能了解系统的组成，相关参考资料：http://www.pathname.com/fhs/pub/fhs-2.3.pdf
								/bin: 所有用户可用的基本命令程序文件
								/sbin: 供系统管理员使用的工具程序
								/boot: 引导系统启动加载器必须用到的各静态文件：kernel, initramfs(initrd),grub等
								/dev: 设备文件及特殊文件
									设备有两种类型：字符设备、块设备
										字符设备（线性设备）：数据交换以字符为单位进行，键盘显示器---按顺序访问
										块设备（随机设备）：多个设备打包发送，硬盘---可以随机访问
								/etc: Host-specific system configuration 系统程序的静态配置文件，只能为静态
								/home: User home directories(optional) 可选的，可独立挂载一个分区的，no program should rely on this directory
										普通的家目录的集中位置；一般每个普通用户的家目录默认为此目录下与用户名同名的目录 /home/USERNAME
								/lib: Essential shared libraries and kernel modules
									The /lib directory contains those shared library images needed to boot the system and run the commands in the root filesystem, ie. by binaries in /bin and /sbin.
									为系统启动或根文件系统上的应用程序（/bin /sbin 提供共享库，以及为内核提供内核模块
									libc.so.*: 动态链接C库
									ld*: 运行时链接器/加载器
									modules: 用于存储内核模块的目录
								/lib64: 64位系统特有的存放64位共享库的路径
								/Media: Mount point for removeable media, cdrom, floppy etc
								/mnt: Mount point for a temporarily mounted filesystem
									其他非关键性文件系统的临时挂载点
								/opt: Add-on application software packages， 附加引用程序的安装位置，第三方应用程序
								/root : Home directory for the root user (optional)
								/srv : Data for services provided by this system 当前主机为服务提供的数据，有特殊性，一般是当前主机自己提供的
								/tmp : Temporary files 为那些会产生临时文件的程序提供的用于存储临时文件的目录，供所有用户执行写入操作，有特殊权限
								/usr: 自己就是一个层级结构，目录里面还有别的文件夹；
									全称：全局共享只读数据路径 universal shared read-only file, 跟user没有关系
									/usr is the second major section of the filesystem. /usr is shareable, read-only data. 
									That means that /usr should be shareable between various FHS-compliant hosts and must not be written to. Any information that is host-specific or varies with time is stored elsewhere.
									Large software packages must not use a direct subdirectory under the /usr hierarchy.
										bin,sbin
										lib, lib64
										include: C程序头文件
										share: 命令手册页和自带文档等架构特有的文件的存储位置
										local: 另一个层级目录
										X11R6：X-window程序的安装位置
										src: 程序源码文件的存储位置
								/usr/local: 用来存储第三方程序的，让系统管理员安装本地应用程序或第三方程序，比如安装一个程序的新版本，这时候老版本存在usr里面，老版本可能会被其他应用所依赖，所以新版本不会覆盖老版本，会安装在local下面
									The /usr/local hierarchy is for use by the system administrator when installing software locally. It needs to
									be safe from being overwritten when the system software is updated. It may be used for programs and data that
									are shareable amongst a group of hosts, but not found in /usr.
									Locally installed software must be placed within /usr/local rather than /usr unless it is being installed to
									replace or upgrade software in /usr
								/var: contains variable data files. This includes spool directories and files, administrative and logging data, and transient and temporary files.	
									存储经常发生变化的数据，例如：logs
										cache 	Application cache data
										lib 	Variable state information
										local 	Variable data for /usr/local
										lock 	Lock files
										log 	Log files and directories
										opt 	Variable data for /opt
										run 	Data relevant to running processes
										spool 	Application spool data
										tmp 	Temporary files preserved between system reboots
								以上目录就是FHS所规定的必须存在的目录，可以读一下http://www.pathname.com/fhs/pub/fhs-2.3.pdf，以深入了解。
								两个特殊目录：
									/proc : Kernel and process information virtual filesystem
											The proc filesystem is the de-facto standard Linux method for handling process and system information, rather
											than /dev/kmem and other similar methods. We strongly encourage this for the storage and retrieval of process
											information as well as other kernel and memory information.
											为了保证一切皆文件二设定的，基于内存（临时的）的虚拟文件系统，为内核及进程运行存储相关信息的。它们多为内核参数，
											例如：net.ipv4.ip_forward, 虚拟为net/ipv4/ip_forward, 存储在/proc/sys/下，所以完整路径：/proc/sys/net/ipv4/ip_forward, 参数值保存在ip_forward文件中
									/sys: sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径，主要作用在于为管理Linux设备提供了一种统一模型的接口	
										参考文件：https://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/
																				
			Linux系统上的文件类型：ls -l命令查看得到
				-rw-------.  1 root root     1426 Nov  3 06:12 anaconda-ks.cfg
				drwxr-xr-x.  2 root root        6 Nov 29 19:44 Desktop
				
				起始字符说明：
				-: 常规文件，即f
				d: directory, 目录文件，实现路径映射的，跟windows不同是文件夹
				b: block device, 块设备，用来映射块设备的文件，支持以block为单位，进行随机访问
				c: character device, 字符设备文件，支持以character为单位，进行线性访问，有秩序的
					major number: 主设备号，用于标识设备类型的，进而确定要加载的驱动程序
					minor number: 次设备号，用于标识同一类型中的不同设备
					主设备号确定了驱动程序，次设备号确定了同一个设备下连接的不同设备，两个号码用逗号分隔，早期时候用8位二进制来表示的
						例如: ls -l /dev
						crw-rw----. 1 root video    10, 175 Jan 18 20:20 agpgart
						crw-------. 1 root root     10, 235 Jan 18 20:20 autofs
							10: major number
							175: minor number
				l: symbolic link, 符号链接文件，快捷方式，软连接，soft link
				p: pipe，命名管道，有名字的管道，还有匿名管道
				s: socket, 套接字文件 实现两个进程进行通信时进行套接的,主要用于服务提供的
			
			基本命令：
				命令类型：
					命令根据其是否在文件系统上存在一个与之对应的独立文件，可以分为内建命令和外部命令
						外部命令：在系统文件里面都有一个独立文件，理论上说所有命令都是外部命令
						内部命令：外部命令自带很多命令，例如外部命令bash自带了很多命令
						区分内外部命令： type命令，如果提示是builtin就是内部命令
													外部命令显示为命令文件路径
												注意：命令可以有别名，别名可以与原名相同，此时原名被隐藏
												例如：[root@localhost ~]# type ls
													  ls is aliased to `ls --color=auto'
												如果想运行命令本身：\ls，这时候输出的结果是不带颜色的
										查看所有命令别名：alias, 可以自定义命令别名
										自己定义别名：alias NAME='COMMAND', 只对当前shell登录进程有效,如果想永久有效，去改配置文件
										撤销别名：unalias NAME
		
				which - shows the full path of (shell) commands.显示命令完整路径
					[root@localhost ~]# which which
					alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'      # 默认显示别名
						/usr/bin/alias
						/usr/bin/which

					[root@localhost ~]# which --skip-alias which      # 不显示别名
					/usr/bin/which
				whereis - locate the binary, source, and manual page files for a command
					whereis [options] name
						-b: 搜索二进制
						-m: 搜索手册
						-s: 搜索源文件
				who - show who is logged on
				w - Show who is logged on and what they are doing. 增强版的who命令
				
				
		bash的基础特性：
			命令历史：shell进程会在其会话中保存此前用户提交执行的命令
				~]# history 能提供从装机到现在所有执行过的历史命令，这些历史记录是保存在文件中的
							history是shell的内嵌命令，是shell的特性
							定制history的功能可以通过环境变量实现
								HISTSIZE: 定义了history命令历史的保存条数，通过echo $HISTSIZE可以查看
								HISTFILE: 持久保存命令历史的文件， 通过echo $HISTFILE获得， 
								[root@localhost ~]# echo $HISTFILE
								/root/.bash_history		进入到root目录后，通过 cat .bash_history可以查看到之前已经保存的历史，本次开机后的命令还保存在内存中，并未写入
							查看history的用法： help history
								history -d 100 删除history的第100条记录
								history -d 100 5 从100条开始删5条
								history -c 清空内存中的历史记录，可以通过-r读回来
										-w	write the current history to the history file and append them to the history list 将当前历史写入文件保存
										-r 	从/root/.bash_history中读到内存中
								history 10 显示最近10条
								!5: 再次执行历史列表中的第5条命令
								!!: 再次执行上一次命令，直接用上方向键就行了
								!STRING: 再一次执行命令历史列表中最近一个以STRING开头的命令
							调用上一条命令的最后一个参数：ESC+.   ESC按一下后可以松开再按.
								例如执行了 ls /root 之后，需要再次是从/root，cd ESC+.就可以达到cd /root的效果
								也可以使用!$，例如：cd !$ 就相当于cd /root，这些快捷键应该会再写bashshell的时候有用
						控制历史文件记录的方式：
							环境变量：HISTCONTROL
								ignoredups: 忽略重复命令
								ignorespace: 忽略以空白字符开头的命令,设置： HISTCONTROL=ignorespace， 然后只要命令以空格开头，系统都不记录
								ignoreboth: 以上两者同时生效
							修改变量的值：
								NAME='VALUE' 仅对当前shell进程有效
				回顾：
					FHS、命令以及bash命令历史
						FHS：非常基础和重要的
							/bin, /sbin 存放二进制文件；/lib, /lib64存放库文件， /etc配置文件, 
							/home /root 用户家目录
							/boot 引导文件
							/media /mnt 挂载
							/proc /sys 伪文件/虚拟文件系统
							/tmp 临时文件
							/srv 为服务提供数据
							/opt 独立的文件系统
							/dev 放设备的
							/usr 有很多目录，提供全局共享的只读文件路径，安装程序的，关键的服务类 工具类的 
								bin sbin lib lib64 share include
							/usr/local
							/var 经常发生变化的
								cache lib log 
					命令：which whereis who w alias unalias
					命令历史：history
					文件类型：-,d,b,c,l,p,s
	Linux基础知识
		bash基础特性：
			命令补全：tab键
				shell程序会在接收到用户执行命令的请求，分析完成之后，最左侧的字符串会被当做命令；
				命令查找机制：
					1. 查找内部命令；
					2. 根据PATH环境变量中设定的目录，自左而右逐步搜索目录下的文件名；
				给定的打头字符串，如果能唯一标识某命令程序文件，则直接补全；
				如果不能唯一标识某命令程序文件，再按一次tab键一次，会给出列表；
			路径补全：按tab键也可以，实际上原理不一样；路径补全是根据给定的起始路径补全
			使用补全机制能避免出错
		目录管理类的命令：
			mkdir, rmdir
			 mkdir [OPTION]... DIRECTORY...
				-p: 自动按需创建父目录
				-v: 打印创建的内容
				-m MODE: 创建目录时直接给定权限，否则是默认权限
			 rmdir [OPTION]... DIRECTORY... 删除空目录，目录不空不能删除
				-p: 删除某空目录后，其父目录是空，则删除，以此向上递归
				-v: 显示过程
			
			问题1：如何创建/tem/x/y1, /tem/x/y2, /tem/x/y1/a, /tem/x/y1/b 
			问题2：如何创建a_c, a_d, b_c, b_d
			bash的基础特性之：命令行展开
				~: 自动展开为用户的家目录，或指定的用户家目录
				{}: 可承载一个以逗号分隔的路径列表，并将其展开为多个路径
					例如：/tem/{a,b}相当于/tem/a, /tem/b
				mkdir -pv /tem/x/{y1/{a,b},y2} 一个命令可以解决第一个问题,然后tree /tem可以查看， 如果没有tree，则使用yum install tree安装
				mkdir -v {a,b}_{c,d}, 解决第二个问题
			问题3：创建如下目录结构
				/tem/mysysroot/
					bin
					sbin
					etc
						sysconfig
							network-scripts
					usr
						bin
						sbin
						local
							bin
							sbin
							etc
							lib
						lib
						lib64
					var
						cache
						log
						run
				mkdir -pv /tem/mysysroot/{bin,sbin,etc/sysconfig/network-scripts,usr/{bin,sbin,local/{bin,sbin,etc,lib},lib,lib64},var/{cache,log,run}}
			 
			tree命令，以树状结构显示文件层级结构，没有安装的话使用yum install tree
				-L # 指定要显示的层级数
			
		bash的基础特性：命令的执行状态结果
			bash通过状态返回值来输出此结果
				成功：0
				失败：1-255
			命令执行完成后，其状态返回值会保存于bash的特殊变量$?中,执行完命令接着使用echo $?即可获得命令执行的返回值
				例如：ls /etc
					   echo $?
		引用命令的执行结果：
			$(COMMAND)或`COMMAND`    注意这里不是单引号
			例如：mkdir $(date +%Y%m%d%H%M%S)
		bash的引用：
			强引用：''	变量也不会替换
			弱引用：""  变量会替换 
			命令引用：$(COMMAND)或者`COMMAND`
		bash的快捷键：
			ctrl+a 跳转至命令行首
			ctrl+e 跳转至命令行尾
			ctrl+u 删除命令行开头到光标之间的所有字符
			ctrl+k 删除光标到末尾的所有字符
			ctrl+l 清屏
		
	文本文件查看类命令：
		cat,tac,head,tail,more,less
		
		分屏查看：more less
		head:看一个文件的前#行，默认显示10行
			head -n 20 /etc/rc.d/init.d/functions  查看前20行
			或 head -20 /etc/rc.d/init.d/functions
		tail: 查看一个文件的后#行，默认10行
			tail -n 20 /etc/rc.d/init.d/functions  查看最后20行
			或 tail -20 /etc/rc.d/init.d/functions
			tail -n 20 -f /etc/rc.d/init.d/functions
				-f：如果被查看的文件是动态增加的，可以实时查看追加的内容，用于查看日志增加很有用；
	stat命令
		stat - display file or file system status
		stat FILE...

		文件：两类数据组成
			元数据：metadata  一本书的目录，描述属性，使用stat看到的是文件的元数据
			数据：data		  一本书的正文，使用cat等文本查看工具看到的就是数据
		Access: 2018-01-21 12:12:27.075999937 +0800   最近访问时间
		Modify: 2017-05-03 18:17:50.000000000 +0800	  数据改变时间，例如增加数据内容
		Change: 2017-11-03 06:07:59.815998266 +0800   元数据改变时间，例如改名
	touch命令：
		 touch - change file timestamps, Update the access and modification times of each FILE to the current time.
		-a     change only the access time
		-c,    do not create any files
		-m     change only the modification time
		-t STAMP use [[CC]YY]MMDDhhmm[.ss] instead of current time
		例如：
		[root@localhost tem]# touch -mt 200001022233.56 functions 
		[root@localhost tem]# stat functions 
			Access: 2018-01-21 21:30:12.606008000 +0800   访问时间没有改变
			Modify: 2000-01-02 22:33:56.000000000 +0800	  改变了Modify时间
			Change: 2018-01-21 21:32:44.853006574 +0800   元数据时间就是执行改变Modify时间命令的时间
		注：Access和Modify时间的改变，元数据时间Change时间就会改变成执行Access和Modify时间命令的时间
	
	文件管理命令：cp mv rm
		cp命令：copy, 复制文件是复制的文件的数据，而不是复制的文件的metedata, 复制的过程：先在目标位置新建一个空文件，然后从源文件抽取数据流，填充到目标文件，这样就完成了复制；元数据不会被复制过来；
		cp [OPTION]... [-T] SOURCE DEST  单源文件复制
		cp [OPTION]... SOURCE... DIRECTORY  多源文件复制，SOURCE...表示多个源
		cp [OPTION]... -t DIRECTORY SOURCE... 多源文件复制的另外一种写法，（多）源文件写在后面，-t表示targeet
			单源复制：cp [OPTION]... [-T] SOURCE DEST
				如果目标不存在，则新建目标文件，再填充源文件的数据流进去新文件；
				如果dest存在
					dest是非目录文件，则覆盖目标文件；
					如果dest是目录，则先在dest目录中创建一个与源文件同名的文件，再将源文件数据流复制到目标文件
			多源复制（多个源文件）：cp [OPTION]... SOURCE... DIRECTORY
				如果dest不存在，则不能复制；
				如果dest是非目录文件，则不能复制；
				如果dest是目录文件，则分别复制每一个源文件至目标目录中，并保留原名；
			常用选项：
				-i: interactive 与用户交互，提示是否覆盖；
				-f: force 强制覆盖目标文件，不提醒；如果目标文件不能打开，则移除目标文件，并复制
				-r: 递归复制目录
				-d: 复制符号链接文件本身，而非其指向的源文件
				-a：-dR --preserve=all, archive,用于实现归档
				--preserve=
					mode:权限
					ownership: 属组和属主
					timestamps: 时间戳
					context: 扩展属性
					links: 符号链接
					all: 上述所有属性
		mv: move or rename
			没有-r选项
			-i: interactive
			-f: force
		rm: remove
			-i: interactive
			-f: force
			-r: recursive
			自杀的方法：rm -rf /
						rm -rf /*
			注意：生产环境，不要直接删除，而是mv到一个目录；
	变量：
		命名的内存空间--是在程序中快速便捷的引用一块内存空间，而在里面实现数据存取的机制
			变量类型：整型，浮点型，字符型，布尔型，日期时间型
				字符型
				数值型
					精确数值型：整型
					近似数值：单精度，双精度
				变量类型决定了数据：
					存储格式
					数据范围
					参与运算的方式
			问题：浮点数据如何存储，单精度，双精度是什么？
		变量的赋值操作：
			name=tom
回顾：
	bash基础特性：命令补全、路径补全、命令引用
	文件或目录的复制、移动、删除
	变量：变量类型
		储存格式、数据范围、参与运算

bash的基础特性：
	globbing:文件名通配(整体文件名匹配，而非部分)
		匹配模式：元字符
			*: 匹配任意长度(0长度也匹配)的任意字符
			?: 匹配任意单个字符
			[]: 匹配指定范围内的任意'单个'字符
				几种特殊格式：
					[a-z],[A-Z],[0-9],[a-z0-9],[abcxyz]
						注：[a-z]和[A-Z]将匹配任意一个字母，不区分大小写
					[[:upper:]]: [:upper:]表示所有大写字母
					[[:lower:]]: [:lower:]表示所有小写字母
					[[:alpha:]]: 所有字母
					[[:digit:]]: 所有数字
					[[:alnum:]]: 所有字母和数字
					[[:space:]]: 所有空白字符
					[[:punct:]]: 匹配所有标点符号
					touch p\ a: 这样将会创建一个p a的文件，中间的空格因为\被转义，所以表示其本身的意思空格,而不是分隔符
					pa[0-9][0-9]: pa跟两个数字
			例如：ls /etc/pa*   匹配pa开头的所有文件
				  ls -d /etc/pa???? 
			[^]:匹配指定范围外的任意单个字符
				[^[:upper:]]: 任意大写字母以外的字符
				[^[:alnum:]]: 非数字，非字母的字符
			Linux命令行可以直接使用globbing机制来匹配
			
			练习1：显示/var/log目录所有以l开头，以一个小写字母结尾，且中间出现一位数字的文件或目录；
				ls /var/l[0-9][[:lower:]]  如果加-d ls -d /var/l[0-9][[:lower:]], 则是目录的，就只显示目录本身，文件不受影响，会被正常显示
			练习2：显示/etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录
				ls /etc/[^[:alpha:]]*[^[:digit:]]
			练习3：显示/etc目录下，以非字母开头，后面接一个字母及其他任意长度任意字符的文件或目录
				ls /etc/[^[:alpha:]][a-z]*
			练习4：复制/etc目录下，所有以m开头，以非数字结尾的文件或目录至/tem/magedu.com目录
				mkdir /tem/magedu.com
				cp -r /etc/m*[^[:digit:]] /tem/magedu.com/
				\cp -rf /etc/m*[^[:digit:]] /tem/magedu.com/  强行复制并覆盖，不提示，将cp转义掉，因为系统默认cp是cp -i的alias
			练习5：复制/usr/share/man目录下，所有以man开头，后跟一个数字结尾的文件或目录至/tem/man/目录下
				mkdir /tem/man
				cp -ia /usr/share/man/man*[0-9] /tem/man
			练习6：复制/etc目录下，所有以.conf结尾，且以m,n,r,p开头的文件或目录至/tmp/conf.d/目录下；
				[root@localhost ~]# mkdir /tem/conf.d
				[root@localhost ~]# cp -ia /etc/[mnrp]*.conf /tem/conf.d
IO重定向及管道：
	程序:指令+数据
		程序也有IO
		可用于输入的设备：文件，键盘设备，文件系统上的常规文件，网卡
		可用于输出的设备：显示器，文件系统上的常规文件，网卡
		程序的数据流有三种：
			输入数据流： <-- 标准输入(stdin:standard input),键盘
			输出数据流：--> 标准输出(stdout),显示器
			错误输出流：--> 错误输出(stderr),显示器,是解释器辅助产生的数据流
			fd: file descriptor, 文件描述符
				标准输入：0
				标准输出：1
				错误输出：2
	IO重定向：
		输出重定向：> 命令执行结果不显示出来，而是导出到另外的文件；
			因为一切皆文件，甚至可以将结果输出到设备上
				例如：cat /etc/issue > /dev/pts/0 这就将issue的内容传输到终端上去了，在终端会显示issue的内容
				注意：重定向很危险，cat /etc/issue > /dev/sda 这样会把硬盘的数据全部覆盖掉，因为/dev/sda是指硬盘，硬盘也是用文件表示的
				特性：覆盖重定向，直接覆盖，不提示的
		输出重定向：>>
			特性：追加输出
		为了避免风险，使用set命令
			set -C 禁止通过输出重定向覆盖已存在的文件
			例如：set -C   关掉覆盖功能，仅仅对当前shell有效
				  cat /etc/issue > /tem/issue.out 如果issue.out已经存在，则命令执行失败
			真要覆盖： 	  cat /etc/issue >| /tem/issue.out
					set +C 关闭功能，可以重定向覆盖了
		将错误信息输出：2> 2>>
			cat /etc/issue1 2> /tem/issue.out
			例如：[root@localhost ~]# cat /etc/issue1 > /tem/issue.out
					cat: /etc/issue1: No such file or directory    这里提示不能输出，因为issue1不存在
				[root@localhost ~]# cat /etc/issue1 2> /tem/issue.out  现在就可以输出了
				[root@localhost ~]# cat /tem/issue.out
				cat: /etc/issue1: No such file or directory
		合并正常输出流和错误输出流：
			(1) 使用&>, &>>输出不管对错的信息
			(2) COMMAND > /PATH/TO/SOMEFILE 2>&1  
				COMMAND >> /PATH/TO/SOMEFILE 2>&1    追加只需要改前面的>
			
				详细解释看文章：http://blog.csdn.net/ithomer/article/details/9288353
					注意这里的>指的是标准输出，实际上应该是1>这样子；一般将1省略掉；
					2>指的是错误输出， COMMAND > /PATH/TO/SOMEFILE 2>&1里的2>&1是表示将错误输出重定向到标准输出；
					1不是指的文件，而是指的标准输出管道，&指的是在后台执行，相当于是二次重定向
			特殊设备：/dev/null  任何数据输出给/dev/null都会被丢弃，用于接收毫无意义的输出
				例如：ls carrr &> /dev/null  不管成不成功，全部输出到/dev/null
					  echo &?    这里查看上一条命令有没有执行成功
				这种方式用来只需要看状态码的情形；
		输入重定向：<
			tr - translate or delete characters   
			tr [OPTION]... SET1 [SET2]   tr命令不接受file作为参数，说明是需要输入重定向的
				把输入的数据当中的字符，凡是在SET1定义范围内出现的，通通对位转换为SET2出现的字符
					例如在命令行：
					[root@localhost ~]# tr [a-z] [A-Z]      命令行也可以这样，通过键盘输入数据，这里也可以写成引号：tr 'a-z' 'A-Z'
						how are you 
						HOW ARE YOU
					[root@localhost ~]# tr [a-z] [A-Z] < /etc/issue    输入文件/etc/issue，并将小写改成大写
					\S
					KERNEL \R ON AN \M
					
					[root@localhost ~]# tr -d [Kbc] < /etc/issue     -d删除的意思，这里是删除[]里面包含的字符
					\S
					ernel \r on an \m
				注意：不会修改原文件，只是将原文件输入
			<< : HERE DOCUMENT << 
				(1). cat << EOF(end of file, 输入EOF就是告诉解释器，输入完了)
						[root@localhost ~]# cat << EOF
						> HELLO
						> EOF
						HELLO

				(2). cat > /PATH/TO/SOMEFILE << EOF   这里会生成SOMEFILE这个文件
						[root@localhost ~]# cat > cat.out <<EOF
						> HELLO
						> this is << EOF test
						> EOF
						[root@localhost ~]# cat cat.out
						HELLO
						this is << EOF test
		管道：连接程序，实现将前一个命令的输出直接定向后一个程序当作输入数据流
			COMMAND1 | COMMAND2 | COMMAND3| ...
				
				[root@localhost ~]# tr [a-z] [A-Z] < /etc/issue
				\S
				KERNEL \R ON AN \M

				[root@localhost ~]# cat /etc/issue | tr [a-z] [A-Z]    这里是将cat命令的输出直接当作输入给后一个命令
				\S
				KERNEL \R ON AN \M
			
			[root@localhost ~]# who | head -2 | tr [a-z] [A-Z] | tr -d [0-9]    看登录了几个终端，只输出前两行，将小写换成大写，删除所有的数字
			USER   :           -- : (:)
			ROOT     PTS/        -- : (...)
		
		经常跟管道配合使用的命令
			tee - read from standard input and write to standard output and files
			tee [OPTION]... [FILE]...
				-a, --append  append to the given FILEs, do not overwrite
			
			[root@localhost ~]# who | tee -a /tem/tee.who | tr [a-z] [A-Z]   这里的tee命令将who的输出分成了两份，一份给了文件/tem/tee.who，一份给了tr命令，相当于可以以文件的形式保存命令执行结果
				USER01   :0           2018-01-21 12:12 (:0)
				ROOT     PTS/1        2018-01-25 19:56 (192.168.8.1)
				ROOT     PTS/2        2018-01-25 23:08 (192.168.8.1)
				USER01   PTS/0        2018-01-24 22:34 (:0)
			[root@localhost ~]# cat /tem/tee.who
				user01   :0           2018-01-21 12:12 (:0)
				root     pts/1        2018-01-25 19:56 (192.168.8.1)
				root     pts/2        2018-01-25 23:08 (192.168.8.1)
				user01   pts/0        2018-01-24 22:34 (:0)
		练习：将/etc/passwd的前6行转换成大写输出到屏幕上
			head -n 6 |tr [a-z] [A-Z]

	用户、组、权限管理
		Multi-tasks, Multi-Users 
		每个使用者：用户ID，专用的识别码
			用户标识、密码：
				认证：Authentication
				授权：Authorization
				审计：Account / Audition 看有没有乱用权限
			组：用户组-->用户的容器，将多个用户合并形成一个逻辑组件，便于权限分配
		对于Linux，用户类别：
			管理用户
			普通用户
				系统用户
				登录用户
			用户标识：UserID, UID
				默认：16位二进制数字：0-65535
					管理员：0
					普通用户：1-65535，一般只用到60000
						系统用户：1-999(centos7), 1-499(centos5-6)
						登录用户：1000-60000(centos7)，500-60000(centos5-6)
				名称解析：名称转换
					Username <--> UID
					根据名称解析库进行：/etc/passwd 这个文件保存的是用户的解析库
		用户组：
			组类别1：
				管理员组
				普通用户组
					系统用户组
					登录用户组
				组标识：GroupID --> GID
					普通用户组：1-65535，一般只用到60000
							系统用户组：1-999(centos7), 1-499(centos5-6)
							登录用户组：1000-60000(centos7)，500-60000(centos5-6)
				名称解析：groupname <--> gid
					解析库：/etc/group
				
			组类别2：
				用户的主/基本组
				用户的附加组
			组类别3：
				用户的私有组：组名同用户名，且只包含一个用户
				公共组：组内包含多个用户
		认证信息：
			通过比对事先存储的与登录时提供的信息是否一致；
			password保存：
				转换为加密格式，单向加密方式；
				早期放在/etc/passwd但是这个文件所有用户都可以访问和读取，不安全；
				现在放在/etc/shadow, 普通用户是无法访问的
				组的密码：/etc/gshadow
			加密算法：plain text --> cipher text
				对称加密：加密和解密使用同一个密码；
				非对称加密：加密解密用的是一对密钥
					公钥：public key
					私钥：private key
				单向加密：只能加密，不能解密，提取数据特征码；
					定长输出：只是提取指纹，跟原数据的size没有关系
					雪崩效应：一点点改变会造成加密结果的巨大变大
						例如：[user01@localhost root]$ echo "how are you?" | md5sum
								ce55c98ac24d4c7764877fa58ab441ef  -
							  [user01@localhost root]$ echo "how are you." | md5sum
								5bd65df962ddf52bc545606a44959778  -
							  [user01@localhost root]$ echo "how are you." | sha512sum
								8b9f6311559dbe47be9b2a29bfde1c7d1b3dafec1f12a7e20c47b94bb80152176c4086ccdc0b0cf814585d6dd6ef0fa0615b2a26b1c334863fe2bc6ffc51d719  -
							  [user01@localhost root]$ echo "how are you?" | sha512sum
								ac96798efe19e41490484ba4b8fd611ab2fb2803d35b8e23b4e0c24a773ca90229aae60304a4ded7066389d7997038789d13ab63058dec0c1e2ebd76cd92afc5  -
							[user01@localhost root]$ echo "how are you?asdsfdfsdfdfgggggggggggggggggggggggggggggggggggggggggggggg" | sha512sum
								feef74a5d6b7e87befafe39730c0bf31fd246b84b30fad652e0506dc95568f31417e81f72ac4ca1a092c45f3cedec3107093a062ec0474cd8845d8f565520153  -    定长输出
			算法：
				md5: message digest, 128bits输出
				sha: secure hash algorithm, 160bits输出
				sha256: 256bits输出
				sha384
				sha512
				系统用户密码加密的时候会自动加一些salt（随机数）进去，以避免同样的字符串加密得出同样的加密结果；
				Linux密码加密后登录验证的过程：
					首先在设置密码的时候，会通过加密算法将密码字符串加密，这时候会加入salt一起进行加密，得到的加密字符串存放在/etc/shadow文件；
					登录的时候，用户输入密码后，系统会从/etc/shadow拿出这个用户的salt和输入的密码进行加密，把加密后的密文和存储的密文进行比对就验证成功了；
	
	/etc/passwd信息存储的格式：用户信息库
		使用cat /etc/passwd查看文件，第三个参数:500以上的,就是后面建的用户，其它则为系统的用户.
			root:x:0:0:root:/root:/bin/bash
			user01:x:1000:1000:user01:/home/user01:/bin/bash
			centos:x:1001:1001::/home/centos:/bin/bash
				存储格式：name:password:UID:GID:GECOS:directory:shell
					如何看passwd命令/文件的使用说明：	
						whatis passwd, 查看passwd的mannual在哪里
						man 5 passwd 指定查看passwd在第五章的使用帮助，可以看到以下解释
						name:password:UID:GID:GECOS:directory:shell
						password    This is either the encrypted user password, an asterisk (*), or the letter 'x'.  (See pwconv(8) for an explanation of 'x'.)
				user01 用户名
				x 密码占位符，影子口令，到/etc/shadow保存密码
				1000 UID
				1000 GID 组ID
				GECOS 用户的附加信息
				home/centos 用户的家目录
				/bin/bash 用户的默认shell程序
	/etc/shadow
		whatis shadow
		man 5 shadow
			shadow - shadowed password file, shadow is a file which contains the password information for the system's accounts and optional aging information.
			Each line of this file contains 9 fields, separated by colons (“:”), in the following order:
		密码格式：
		user01:$6$k2HbLwd4uPF3kMcO$z1C/3eviLes448msR8zqUq3WIG0qN7q5KoxHAyNLbVEJpbfa.TVkExKtjdbEHF4IX2I3/KeFF5OZyEBT3tDuH1::0:99999:7:::
		$6: 表示用sha5加密
		$k2HbLwd4uPF3kMcO：salt，不包含$符号
		$z1C/3eviLes448msR8zqUq3WIG0qN7q5KoxHAyNLbVEJpbfa.TVkExKtjdbEHF4IX2I3/KeFF5OZyEBT3tDuH1： 加密后的字符串，不包含$符号
		用户名：加密的密码：最近一次次该密码的时间：最短使用期限：最长使用期限：警告期限：过期期限：保留字段		
				 
	/etc/group
		whatis group
		man group
			group - user group file The /etc/group file is a text file that defines the groups on the system.  There is one entry per line, with the following format:
            group_name:password:GID:user_list
	用户管理的相关命令：
		useradd, userdel, usermod, passwd, groupadd, groupdel, groupmod, gpasswd, chage, chsh, id, su
		

	Linux用户和组管理
		安全上下文：
			进程：以其发起者的身份运行，进程对文件的访问权限取决于发起此进程的用户的权限；
			系统用户：为了能够让那些后台进程或服务类进程以非管理员身份运行，通常需要为此创建多个普通用户，这类用户不用登录系统；
		groupadd: 组创建命令
			-g GID:手动指定GID，默认是上一个组的GID+1
			-r: 创建系统组
				例如：
				[root@localhost ~]# groupadd test01   增加普通组
				[root@localhost ~]# groupadd -r testroot   增加系统组
				[root@localhost ~]# tail /etc/group
				gnome-initial-setup:x:986:
				stapusr:x:156:
				stapsys:x:157:
				stapdev:x:158:
				tcpdump:x:72:
				avahi:x:70:
				slocate:x:21:
				centos:x:1001:
				test01:x:1002:		普通组的GID是在1000-6000	
				testroot:x:985:		系统组的GID是在1-999
		groupmod: 修改组属性
			groupmod [选项] GROUP
				-g GID: 修改GID
				-n new_name: 修改组名
		groupdel: 删除组
			groupdel GROUP
		
		useradd: 创建用户
			[root@localhost ~]# which adduser
			/usr/sbin/adduser
			[root@localhost ~]# file `which adduser`   命令引用，不知道为什么，用管道不行：(因为这里file要有个对象)which adduser | file
			/usr/sbin/adduser: symbolic link to `useradd'

			-u, --uid UID指定UID
			-g, --gid GROUP 指定基本组ID，此组得事先存在
			-G, --groups GROUP1[,GROUP2,...[,GROUPN]]] 指明用户的附加组，多个组之间用逗号分隔
			-c, --comment, COMMENT 指明注释信息
			-d, --home, HOME_DIR 以指定的路径为用户的家目录，创建方式是通过复制/etc/skel目录并重命名实现的，初始目录有一些隐藏文件
						如果指定的家目录事先存在，则不会从skel目录复制任何文件
			-s，--shell SHELL  指定用户的默认shell，可用的所有常规shell列表在/etc/shells文件中
			-r，--system 创建系统用户
		注意：创建用户时的诸多默认设定配置文件为/etc/login.defs
		
		useradd -D: 显示创建用户的默认配置
		useradd -D 选项：修改默认选项的值
		修改的结果保存于/etc/default/useradd文件中，可以直接编辑此文件来实现
			
		[root@localhost ~]# adduser gentoo
		[root@localhost ~]# tail -1 /etc/passwd
		gentoo:x:1003:1004::/home/gentoo:/bin/bash      //添加用户后，系统会自动添加一个组给这个用户，默认UID=GID,这里GID被占用了；这个组就是这个用户的私有组
		[root@localhost ~]# tail -1 /etc/group
		gentoo:x:1004:
		
		[root@localhost ~]# useradd -u 3000 openstack    //指定UID创建用户
		[root@localhost ~]# tail -1 /etc/passwd
		openstack:x:3000:3000::/home/openstack:/bin/bash
		[root@localhost ~]# tail -1 /etc/group
		openstack:x:3000:

		[root@localhost ~]# groupadd mysql     //添加组mysql
		[root@localhost ~]# useradd -G mysql archlinux    //添加指定组的用户archlinux
		[root@localhost ~]# tail /etc/group
		avahi:x:70:
		slocate:x:21:
		centos:x:1001:
		test01:x:1002:
		testroot:x:985:
		docker:x:1003:
		gentoo:x:1004:
		openstack:x:3000:
		mysql:x:3001:archlinux   //组mysql是用户archlinux的附加组
		archlinux:x:3002:    //组archlinux是用户archlinux的私有组

		/etc/shells
		[root@localhost ~]# cat /etc/shells
		/bin/sh
		/bin/bash
		/sbin/nologin
		/usr/bin/sh
		/usr/bin/bash
		/usr/sbin/nologin
		/bin/tcsh
		/bin/csh

		usermod命令：修改用户属性
			-u 修改用户UID
			-g 修改用户所属的基本组
			-G 修改用户所属的附加组，原来的附加组会被覆盖
			-a 和-G一同使用，用于追加新的附加组
			-c 修改注释信息
			-d 修改用户家目录，用户原有的文件不会被转移到新的位置
			-m 和-d一起使用，用于将原来的家目录移动为新的家目录，原来的家目录文件移动到新的家目录
			-l 修改用户名
			-s 修改用户的默认shell
			-L 锁定用户密码，即在用户原来的密码字符串之前添加！，禁止用户登录
			-U 解锁用户密码
		userdel 删除用户
			-r 删除用户时一并删除家目录，默认不删除
		注：只有root用户有权限更改属主属组
		
		passwd命令 实现密码管理
			(1) passwd 修改用户自己的密码
			(2) passwd USERNAME: 修改指定用户的密码，但仅root用户有权限
				-l, -u: 锁定和解锁用户
				-d 清除用户密码
				-e DATE: 指明用户账号的过期时间
				-n DAYS: 密码最短使用期限
				....
				--stdin:
					echo "PASSWORD" | passwd --stdin USERNAME   脚本中这样用
		gpasswd命令：
			组密码文件: /etc/gshadow
			组密码作用：用于当用户要切换基本组到别的组的时候有个限制，需要输入密码才能切换成功，如果将要切换的基本组没有设置密码则不能切换；
			newgrp命令：临时切换指定的组为基本组，退出切换使用exit命令，这个不知道有什么用，生产环境再说。
				newgrp [-] [group]
					-: 会模拟用户重新登录以实现重新初始化其工作环境
			gpasswd [选项] group
				-a USERNAME: 向组中添加用户
				-d USERNAME: 从组从移除用户
			chage 更改用户密码过期信息
				-d
				-E
				-W
				-m
				-M
			id命令 id - print real and effective user and group IDs
				-u 仅显示有效的UID
				-g 仅显示用户的基本组ID
				-G 显示用户所属的所有组ID
				-n 显示名字而非ID
			su命令：switch user 
				登录式切换：会通过重新读取用户的配置文件来重新初始化
					su - USERNAME
					su -l USERNAME
				非登录式切换：不会读取目标用户的环境配置文件进行初始化
					su USERNAME
				例子：
				[root@localhost ~]# pwd    当前登录用户 
				/root
				[root@localhost ~]# su gentoo  非登录式切换 
				[gentoo@localhost root]$ pwd   还是处于root工作目录
				/root
				[gentoo@localhost root]$ exit
				exit
				[root@localhost ~]# pwd
				/root
				[root@localhost ~]# su - gentoo  登录式切换
				Last login: Thu Mar 29 07:37:28 CST 2018 on pts/1
				[gentoo@localhost ~]$ pwd  当前工作目录
				/home/gentoo
			注：管理员可无密码切换，非管理员需要密码才能切换
					-c 'COMMAND': 仅以指定用户的身份运行此处指定的命令
			其他几个命令：chsh 修改当前shell  chsh 
			   -s, --shell shell
					Specify your login shell.
			   -l, --list-shells
					Print the list of shells listed in /etc/shells and exit.
			   -u, --help
					Print a usage message and exit.
			   -v, --version
					Print version information and exit.
			
			finger — user information lookup program
			finger USERNAME   显示用户信息
			chfn USERNAME  改变用户信息 change finger
			whoami
			
			命令总结：groupadd groupmod groupdel useradd usermod userdel passwd gpasswd gpasswd newgrp id su chage 
			
	
	权限管理：
		[root@localhost ~]# ls -l /etc/issue
		-rw-r--r--. 1 root root 23 Aug 30  2017 /etc/issue
			rwxrwxrwx:
				左三位：定义user(owner)的权限
				中三位：定义group的权限
				右三位：定义other的权限
			
		进程安全上下文：
			进程对文件访问权限应用模型：
				1. 进程的属主与文件的属主是否相同，如果相同则应用属主权限；
				2. 否则，检查进程的属主是否属于文件的属组，如果是，则应用属组的权限；
				3. 否则，就只能应用other的权限；
		权限：
			r: readable
			w: writable
			x: excutable
				文件：默认情况下任何文件都不应该有执行权限
					r: 可获取文件的数据，文件数据，元数据
					w: 可修改文件的数据
					x: 可将此文件发起运行为进程
				目录：
					r: 可使用ls命令获取其下的所有文件列表，不能包含详细信息，不能使用ls -l
					w: 可修改此目录下的文件列表，即创建或删除文件，包含目录，子目录
					x: 可cd至此目录，作为working directory， 且可使用ls -l获取所有文件详细属性信息
				ownership: user group
				mode: rwxrwxrwx 
		权限组合机制：
			--- 000  0
			--x 001  1
			-w- 010  2
			-wx 011  3
			r-- 100  4
			r-x 101  5
			rw- 110  6
			rwx 111  7   8进制权限表示法
		练习：rw-rw-r--  110 110 100   664
			  rwxrwxr-x  111 111 101   775
			  rwxr-x---  111 101 000   750
			  rw-------  110 000 000   600
			  rwxr-xr-x  111 101 101   755
		
	权限管理命令  用户仅能修改属主为自己的那些文件的权限
       chmod - change file mode bits

	   SYNOPSIS
		   chmod [OPTION]... MODE[,MODE]... FILE...
		   chmod [OPTION]... OCTAL-MODE FILE...
		   chmod [OPTION]... --reference=RFILE FILE...
			三类用户
				u: 属主
				g: 属组
				o: 其他
				a: 所有
			（1）chmod [OPTION]... MODE[,MODE]... FILE...
				MODE表示法：
					赋权表示法：直接操作一类用户的所有权限位 rwx
						u=r,w,x,rwx,rw... 属主的权限，赋值的时候只需要写需要给什么权限（读、写、执行）
						g=r,w,x... 属组的权限
						o=... 其他权限
						a=... 所有权限
						[root@localhost ~]# ll 1.txt
						-rw-r--r--. 1 root root 18 Jan 21 13:45 1.txt
						[root@localhost ~]# chmod u=r 1.txt    将属主权限设置为r
						[root@localhost ~]# ll 1.txt
						-r--r--r--. 1 root root 18 Jan 21 13:45 1.txt
						[root@localhost ~]# chmod u=rw,g=rwx 1.txt   将属主和属组的权限进行修改，用逗号隔开u,g...
						[root@localhost ~]# ll 1.txt
						-rw-rwxr--. 1 root root 18 Jan 21 13:45 1.txt  
						[root@localhost ~]# chmod ug=rwx 2.txt     可以组合使用
						[root@localhost ~]# ll 2.txt
						-rwxrwxr--. 1 root root 14 Mar 29 22:37 2.txt
						[root@localhost ~]# chmod ugo= 2.txt     所有都没有任何权限，=后面什么都不接就好了
						[root@localhost ~]# ll 2.txt
						----------. 1 root root 14 Mar 29 22:37 2.txt
						[root@localhost ~]# chmod u=rx,g=wx,o= 2.txt
						[root@localhost ~]# ll 2.txt
						-r-x-wx---. 1 root root 14 Mar 29 22:37 2.txt



					授权表示法：直接操作一类用户的一个权限位 r,w,x
						u+, u-   属主
						g+, g-	 属组
						o+, o-   其他
						a+, a-   所有 
					[root@localhost ~]# ll 1.txt
					-rw-rwxr--. 1 root root 18 Jan 21 13:45 1.txt
					[root@localhost ~]# chmod u+x 1.txt  给属主添加执行权限
					[root@localhost ~]# ll 1.txt
					-rwxrwxr--. 1 root root 18 Jan 21 13:45 1.txt   执行添加属主执行权限之后的效果
					还有其他权限设定：u+r,u+w,u+x... g+r,g+w,g+x, o...
					给所有属主属组其他给权限，a可以省掉，例如：
					[root@localhost ~]# chmod 000 2.txt
					[root@localhost ~]# ll 2.txt
					----------. 1 root root 14 Mar 29 22:37 2.txt
					[root@localhost ~]# chmod +r 2.txt        省掉a，直接给所有用户/组read权限
					[root@localhost ~]# ll 2.txt
					-r--r--r--. 1 root root 14 Mar 29 22:37 2.txt
					注意：在给所有用户w权限的时候，会出现给不全，因为w权限太危险
					[root@localhost ~]# chmod +w 2.txt
					[root@localhost ~]# ll 2.txt
					-rw-r--r--. 1 root root 14 Mar 29 22:37 2.txt
					[root@localhost ~]# ll 2.txt
					-r-x--x---. 1 root root 14 Mar 29 22:37 2.txt
					[root@localhost ~]# chmod o+rwx 2.txt     可以一次加多个权限
					[root@localhost ~]# ll 2.txt
					-r-x--xrwx. 1 root root 14 Mar 29 22:37 2.txt


			（2）chmod [OPTION]... OCTAL-MODE FILE...  8进制权限位
					[root@localhost ~]# chmod 660 2.txt   直接赋值8进制数字，一步到位
					[root@localhost ~]# ll 2.txt
					-rw-rw----. 1 root root 14 Mar 29 22:37 2.txt

			（3）chmod [OPTION]... --reference=RFILE FILE... 参考别的文件的权限
					[root@localhost ~]# ll 1.txt 2.txt
					-rwxrwxr--. 1 root root 18 Jan 21 13:45 1.txt
					-rw-rw----. 1 root root 14 Mar 29 22:37 2.txt
					[root@localhost ~]# chmod --reference 1.txt 2.txt     1.txt是被参考的文件，2.txt是要被改变权限的文件
					[root@localhost ~]# ll 1.txt 2.txt
					-rwxrwxr--. 1 root root 18 Jan 21 13:45 1.txt
					-rwxrwxr--. 1 root root 14 Mar 29 22:37 2.txt
			参数：-R, --recursive  change files and directories recursively  递归修改，修改目录及目录下所有目录文件的权限
					一般用于授权表示法 u+w...
					[root@localhost /]# chmod -R u-r mydata/log   将log文件夹及其下的所有文件的用户读取权限去掉了
		
	从属关系管理命令
		chown 更改属主 注：只有root用户有权限更改属主属组
			chown [OPTION]... [OWNER][:[GROUP]] FILE...   其实可以改属主和属组
			[root@localhost mydata]# ll -a
			total 4
			drwxr-xr-x.  3 root root   17 Mar 30 09:45 .
			dr-xr-xr-x. 19 root root  249 Mar 30 09:45 ..
			drwxr-xr-x. 20 root root 4096 Mar 30 09:45 log     先查看log文件夹的属主属组信息，是属于root，同样log里面的文件属主属组信息也都属于root
			[root@localhost mydata]# chown gentoo:mysql log	   使用chown递归修改权限，执行更改属主属组操作，中间的gentoo:mysql也可以用gentoo.mysql来表示，例如root.root
			[root@localhost mydata]# ll -a
			total 4
			drwxr-xr-x.  3 root   root    17 Mar 30 09:45 .
			dr-xr-xr-x. 19 root   root   249 Mar 30 09:45 ..
			drwxr-xr-x. 20 gentoo mysql 4096 Mar 30 09:45 log   属主被改为了gentoo,属组被改为了mysql

			[root@localhost mydata]# chown :mysql log	也可以冒号前面不填属主，则表示只改属组
			
			chown [OPTION]... --reference=RFILE FILE...   参考其他文件的属主属组信息		
			chown --reference=/tmp/tracker-extract-files.1000/ log -R  参考别的文件，递归修改log文件夹的权限
		
		chgrp 只能用来更改属组  基本不用了，一般使用chown就好了
			chgrp [OPTION]... GROUP FILE...
			chgrp [OPTION]... --reference=RFILE FILE...
	思考：用户对目录有写权限，但对目录下的文件没有写权限，能否修改此文件内容？--不能 能否删除此文件？--可以
		实例：
		[user01@localhost mytest]$ ll -a    当前在/mytest/目录下，以user01登录
		total 0
		drwxr-xr-x. 2 user01 user01 22 Mar 30 10:42 .   user01对此文件夹有rwx权限
		drwxr-xr-x. 4 root   root   31 Mar 30 10:33 ..
		----------. 1 user01 user01  0 Mar 30 10:42 test.txt    user01对文件test.txt无任何权限
		[user01@localhost mytest]$ echo >>test.txt
		-bash: test.txt: Permission denied                    追加失败，无权限
		[user01@localhost mytest]$ rm test.txt
		rm: remove write-protected regular empty file ‘test.txt’? y
		[user01@localhost mytest]$ ls      但是有删除权限

	umask: 文件的权限反向掩码，遮罩码：为了避免用户创建的文件/文件夹自动为777而设置的遮罩码
	
		文件：
			666-umask
		目录：
			777-umask
		注意：之所以文件用666（110 110 110）去减，表示文件默认不能拥有执行权限，如果减得的结果中有执行权限，则需要将其加1
		例如：umask:023
				666-023=643, 加1=644   643:110 100 011 加1后 110 100 100 
				777-023=754 754: 111 101 100 
		umask命令：
			umask: 查看当前umask
			umask MASK: 设置umask，如果想实现创建文件/文件夹的默认权限为某指定权限，则可以修改umask，然后创建的文件/文件夹就是指定权限了
				例如: 想实现root用户创建的文件只有读权限，即100 100 100， 那么就是444，则设置umask 222即可，这样再创建的文件都只会有r权限
				[root@localhost test]# umask 222   设置umask为222
				[root@localhost test]# umask
				0222
				[root@localhost test]# touch test2   root用户创建新文件test2
				[root@localhost test]# ll -a
				total 4
				drwxr-xr-x.  2 root root   31 Mar 30 11:45 .
				dr-xr-x---. 17 root root 4096 Mar 30 11:20 ..
				-rw-r--r--.  1 root root    0 Mar 30 11:26 test
				-r--r--r--.  1 root root    0 Mar 30 11:45 test2     test2的权限则为666-222=444（100 100 100）
			注意：此类设定仅对当前shell进程有效；
		[user01@localhost test]$ umask     普通用户默认的遮罩码 0002
		0002
		[root@localhost test]# umask       root用户默认的遮罩码 0022
		0022


	实例：
	[root@localhost test]# touch test   
	[root@localhost test]# ll test
	-rw-r--r--. 1 root root 0 Mar 30 11:26 test    root用户touch的文件权限  666-022=644
	
	[user01@localhost test]$ touch test
	[user01@localhost test]$ ll -a test
	-rw-rw-r--. 1 user01 user01 0 Mar 30 11:25 test   普通用户touch的文件权限  666-002=664 

	完成以下练习：
		1. 新建系统组mariadb, 新建系统用户mariadb, 属于mariadb组，要求其没有家目录，且shell为/sbin/nologin; 尝试root切换至用户，查看其命令提示符；
			groupadd -r mariadb
			useradd -r -g mariadb mariadb
			usermod -s /sbin/nologin mariadb
		2. 新建GID为5000的组mageedu, 新建用户gentoo,要求其家目录为/users/gentoo, 密码同用户名；
			groupadd -g 5000 mageedu
			useradd -d /users/gentoo gentoo
			passwd gentoo
		3. 新建用户fedora, 其家目录为/users/fedora, 密码同用户名
			useradd -d /users/fedora
			passwd fedora
			fedora
			fedora
		4. 新建用户www, 其家目录为/users/www; 删除www用户，但保留其家目录
			useradd -d /users/www www
			userdel www
		5. 为用户gentoo和fedora新增附加组mageedu
			usermod -G mageedu gentoo
			usermod -G mageedu fedora
		6. 复制目录/var/log至/tmp/目录，修改/tmp/log及其内部的所有文件的属组为mageedu, 并让属组对目录本身拥有写权限；
			cp -r /var/log /tmp/    
			chown -R :mageedu /tmp/log 
			chmod -R g+w /tmp/log

NAME
       install - copy files and set attributes， install比cp命令更强大，可以设置文件属性

SYNOPSIS
	单源复制：
       install [OPTION]... [-T] SOURCE DEST
	多源复制：
       install [OPTION]... SOURCE... DIRECTORY
       install [OPTION]... -t DIRECTORY SOURCE...
	创建文件夹：
       install [OPTION]... -d DIRECTORY...
			
	常用选项：
		-m, --mode=MODE: 设定目标文件权限，默认为755
		-o, --owner=OWNER: 设定目标文件属主
		-g, --group=GROUP: 设定目标文件属组
	
	[root@localhost ~]# install /etc/inittab /tmp   
	[root@localhost ~]# ll -d /tmp/inittab
	-rwxr-xr-x. 1 root root 511 Mar 31 10:36 /tmp/inittab   直接install，默认的权限就是755
	[root@localhost ~]# rm /tmp/inittab
	rm: remove regular file ‘/tmp/inittab’? y
	[root@localhost ~]# install -m 640 /etc/inittab /tmp    使用-m参数，指定640权限
	[root@localhost ~]# ll -d /tmp/inittab
	-rw-r-----. 1 root root 511 Mar 31 10:38 /tmp/inittab   权限变成640
	[root@localhost ~]# rm -f /tmp/inittab
	[root@localhost ~]# install -m 640 -o archlinux -g gentoo /etc/inittab /tmp    多个参数一起用，空格隔开就可以了
	[root@localhost ~]# ll /tmp/inittab
	-rw-r-----. 1 archlinux gentoo 511 Mar 31 10:40 /tmp/inittab    验证：权限640，属主：archlinux, 属组：gentoo 
	
	[root@localhost ~]# install -d hello  创建文件夹
	[root@localhost ~]# ll -d hello
	drwxr-xr-x. 2 root root 6 Mar 31 10:44 hello  默认权限755
	[root@localhost ~]# install -m 777 -d nihao  创建文件夹的时候指定权限777
	[root@localhost ~]# ll -d nihao
	drwxrwxrwx. 2 root root 6 Mar 31 10:45 nihao   穿件的文件夹就是777的权限
	
	
	mktemp命令：
	NAME
       mktemp - create a temporary file or directory
	SYNOPSIS
       mktemp [OPTION]... [TEMPLATE]   注意这里的文件名是一个文件名模板
	例如：
	   [root@localhost ~]# mktemp /tmp/tmp.XXXXXXXX
	   /tmp/tmp.TtbK4QMa
	注意：mktemp会将创建的临时文件名直接返回，因此，可直接通过命令引用保存起来
	[root@localhost ~]# myFile=$(mktemp /tmp/tmp.XXXXXXXX)  将命令执行结果赋值给变量
	[root@localhost ~]# echo $myFile  输出变量
	/tmp/tmp.WeBCoW1H
	常用命令：	
		-d 创建临时文件夹
	博客作业：用户及权限管理


bash特性及bash脚本编程初步
	终端，附着在终端的接口程序；
		GUI: KDE, GNome, Xfce
		CLI: /etc/shells
	bash的特性:
		命令行展开：~，{}
		命令行别名：alias, unalias
		命令历史：history
		文件名通配：glob
		快捷键：Ctrl+a, e, u, k, l
	bash特性之：命令hash
		缓存此前命令的查找结果：key-value
			key:搜索键
			value:值
		hash命令：
			hash: 列出缓存列表
			hash -d COMMAND 删除
			hash -r 清空
	bash特性之：变量
		程序：指令+数据
			指令：由程序文件提供；
			数据：IO设备、文件、管道、变量
		程序：算法+数据结构
				算法：解决问题的方法、路径
		变量名：指向内存空间中某段空间的起始位置
			变量名+指向的内存空间
		变量赋值：name=value
		变量类型：决定存储格式、表示的数据范围、参与的运算
			编程语言：对类型的实现要求是否足够严格分为：
				强类型变量：变量是什么类型就是什么类型，不能违反变量规则，num=123, str=34, num+str会出错，c语言如果不事先声明在编译过程中会报错
				弱类型变量：
					bash把所有变量统统视作字符类型，加减自动变为数字类型
					bash不支持浮点数据，除非借助外在工具
					bash中的变量无需事先声明（不需要先在内存中开辟一个空间并起个名），随用随找;相当于把声明和赋值过程同时实现；
			    注：python是强类型语言，但是不用事先声明变量
		变量替换：把变量名出现的位置替换为其所指向的内存空间中的数据；
		变量引用：${var_name}, $var_name
		变量名：变量名只能包含数字，字母和下划线，而且不能以数字开头；
			变量名：见名知意，命名机制遵循某种法则，不能使用程序的保留字，if else then while...
		bash变量类型：
			本地变量：作用域仅为当前shell进程
			环境变量：作用域为当前shell进程及其子进程
			局部变量：作用域仅为某代码片段（函数上下文）
			
			位置参数变量：当执行的脚本的shell进程传递的参数
			特殊变量：shell内置的有特殊功能的变量 $? 0：成功，1-255失败
			
			本地变量：
				变量赋值：name=value
				变量引用：${name},$name
					"": 变量名会替换为其值
					'': 变量名不会替换其值
				查看变量：set
				销毁变量：unset name
					注意：此处非变量引用,不用$符号
			
			环境变量：
				变量赋值：以下赋值对子shell也有效，打开子shell:bash, 使用pstree可以查看当前的命令结构
					(1) export name=value  
					(2) name=value
						export name  或者分成两部
					(3) declare -x name=value
					(4) name=value
						declare -x name
				变量引用：${name},$name
				
				注意：bash内嵌了许多环境变量（通常为全大写字符），用于定义bash的工作环境
					PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD
				
				查看环境变量：export, declare -x, printenv, env
				撤销环境变量：unset name
			
			只读变量：
				declare -r name  一个变量定义成只读后就不能unset不能重新赋值，直到shell进程终止
				readonly name 
			
		bash特性之多命令执行：
			COMMAND1; COMMAND2; COMMAND3...
			逻辑运算：
				运算数：真(true yes on 1)
						假(false no off 0)
				与运算
				或运算
				非运算
				异或：判断是否不同，不同则为1，相同则为0
			短路法则：COMMAND1 && COMMAND2  1为假，2不执行；1为真，2必须执行；例如：touchaa 01 && cat 01 > result.txt
					  COMMADN1 || COMMAND2  1为真，2不执行；1为假，2必须执行  例如：id user01 || adduser user01 


		shell脚本编程：
			编程语言分类：根据运行方式
				编译运行：源代码-->编译器（编译）-->程序文件（运行程序文件编译器不参与），运行更快；现在一般都会有程序管理器，将不同模块分开，一个模块出问题，只需要修改这个模块；
				解释运行：源代码-->运行时启动解释器，由解释器边解释边运行；源代码本身不可执行，需要有解释器处理数据
			根据其编程过程中功能的实现是调用库还是调用外部的程序文件：
				shell脚本编程：
					利用系统上的命令及编程组件进行编程；
				完整编程：
					利用库或编程组件进行编程；
			
			编程模型：过程式编程语言，面向对象的编程语言
				程序=指令+数据
					过程式：以指令为中心来组织代码，数据是服务于代码；
						顺序执行
						选择执行
						循环执行
						代表：C，bash
					对象式：以数据为中心来组织代码，围绕数据来组织指令；
						类(class):实例化对象，method;
						代表：java C++ Python
			
			shell脚本编程：过程式编程，解释运行，依赖于外部程序文件运行；
				如何写shell脚本：
					脚本文件的第一行，顶格：给出shebang，解释器路径，用于指明解释执行当前脚本的解释器程序文件；
						常见的解释器：
							#!/bin/bash
							#!/usr/bin/python
							#!/usr/bin/perl
				文本编辑器：nano
					行编辑器：sed
					全屏幕编辑器：nano,vi,vim
				shell脚本是什么？
					命令的堆积；
					但很多命令不具有幂等性，需要用程序逻辑来判断运行条件是否满足，以避免其运行中发生错误；
				运行脚本：
					1) 赋予执行权限，并直接运行此程序文件；
						chmod +x /PATH/TO/SCRIPT_FILE      给权限
						/PATH/TO/SCRIPT_FILE			   直接输入文件的绝对路径，内核会扫描文件的shebang,然后调用shebang里面指定的解释器，进行执行
					2) 直接运行解释器，将脚本以命令行参数传递给解释器程序    这种比较优雅
						bash /PATH/TO/SCRIPT_FILE
				注意：脚本中的空白行会被解释器忽略；如果要输出空白行，则只需要写一个echo即可，表示输出一个空白行
					  脚本中，输了shebang，余下所有以#开头的行，都会被视作注释行而被忽略，此即为注释；
					  shell脚本的运行是通过运行一个子shell进程实现的；
					  
			练习1：写一个脚本，实现如下功能：
				(1)显示/etc目录下所有以大写P或小写P开头的文件或目录本身； ls -d /etc/[pP]*
				(2)显示/var目录下的所有文件或目录本身，并将显示结果中的小写字母转换为大写后显示； ls -d /var/* | tr [a-z] [A-Z]
				(3)创建临时文件/tmp/myfile.XXXXXXXX; mktemp /tmp/myfile.XXXXXXXX
				
			bash的配置文件：
				两类：
					profile类：为交互式登录的shell进程提供配置
					bashrc类：为非交互式登录的shell进程提供配置
				登录类型：
					交互式登录shell进程：
						直接通过某终端输入账号和密码后登录打开的shell进程
						使用su命令：su - USERNAME, 或者使用su -l USERNAME执行的登录切换；
					非交互式登录shell进程：
						su USERNAME执行的登录切换；
						图形界面下打开的终端；
						运行脚本；
				
				profile类：
					全局：对所有用户都生效；
						/etc/profile
						/etc/profile.d/*.sh    所有.sh文件
						如果要实现用户登录后，给出一个自定义的欢迎信息，可以到/etc/profile.d/目录下，新建一个welcome.sh文件，内容为echo "welcome..."
						welcome.sh文件会再每次用户登录的时候自动执行；
					用户个人：仅对当前用户有效；
						~/.bash_profile   在用户家目录
					功能：
						1、用于定义环境变量；每次shell启动都会起作用
						2、运行命令或脚本；例如用户登录就运行某个脚本，可以在这里配置
				bashrc类：
					全局：
						/etc/bashrc
					用户个人：
						~/.bashrc   在用户家目录
					功能：
						1、定义本地变量；
						2、定义命令别名；
				注意：仅管理员可修改全局配置文件；
				
				交互式登录shell进程：
					/etc/profile --> /etc/profile.d/* --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc
					登录系统运行时，环境取决于这些文件，按照这些文件的顺序加载
				非交互式登录的shell进程：
					~/.bashrc --> /etc/bashrc --> /etc/profile.d/*
					我们自己编写的脚本 运行时 环境取决于这三个文件
				
				命令行中定义的特性，例如变量和别名作用域为当前shell进程的生命周期；
				配置文件定义的特性，只对随后新启动的shell进程有效；
				
				让通过配置文件定义的特性立即生效；
					(1). 通过命令行重复定义一次；
					(2). 让shell进程重读配置文件；相当于重载配置文件
						~]# source /PATH/FROM/CONF_FILE
						~]# ./PATH/FROM/CONF_FILE
				问题1. 定义所有用户都生效的命令别名，例如 lftps='lftp 172.16.0.1/pub'
						/etc/bashrc
				问题2. 让centos用户登录时，提供其已经登录，并显示当前系统时间
						/etc/profile.d/*.sh
		回顾：
			bash的特性：hash，变量
				命令hash: 把此前在path环境命令中查找命令的结果缓存下来 在再次执行时使执行的效率更高，保存方式是hash命令，直接hash就可以查看
				变量：
					本地变量，环境变量，局部变量
					位置参数变量，特殊变量
					
					
					变量赋值：name=value, export name=value, declare -x name=value
					变量引用：$name, ${name}  使用{}引用变量，例如
						[root@localhost /]# animal=sheep
						[root@localhost /]# echo "there are some $animal"
						there are some sheep
						[root@localhost /]# echo "there are some {$animal}s"
						there are some {sheep}s
						[root@localhost /]# echo "there are some ${animal}s"
						there are some sheeps
					销毁变量：unset name
			bash脚本编程，运行脚本
				#!/bin/bash
			bash配置文件
				profile类：登录式shell
				bashrc类：非登录式shell  shell脚本是非登录式shell
				
				登录式shell: /etc/profile --> /etc/profile.d/*.sh  --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc
				非登录式shell: ~/.bashrc --> /etc/bashrc --> /etc/profile.d/*.sh
			
		文本处理工具：
			Linux上文本处理三剑客：
				grep, egrep, fgrep: 文本过滤工具（模式：pattern）工具；这三个可以通过参数调整功能，实现另外两个的功能；
					grep: 基本正则表达式，-E表示egrep, -F表示fgrep
					egrep: 扩展正则表达式，-G, -F
					fgrep: 不支持正则表达式
					
				sed: stream editor, 流编辑器，文本编辑工具
				awk: Linux上的实现为gawk，文本报告生成器（格式化文本）；
				
				正则表达式：Regual Expression, REGEXP
					由一类特殊字符及文本字符所编写的模式，其中有些字符不表示其字面意义，而是用于表示控制或通配的功能；
						分两类：
							基本正则表达式：BRE
							扩展正则表达式：ERE
					元字符：\(hello[[:space:]]\+\)\+
				grep: Global search REgular expression and Print out the line.
					作用：文本搜索工具，根据用户指定的“模式（过滤条件）“对目标文本逐行进行匹配检查；打印匹配到的 整行 文本
					模式：由正则表达式的元字符及文本字符所编写出的过滤条件；
					正则表达式引擎：
					grep OPTIONS PATTERN FILE...
						OPTIONS:
							--color=auto  自动将匹配到的文本着色，高亮显示
							-i: ignore case 文本过滤时忽略字符大小写
							-o: 仅显示匹配到的字符串本身
							-v: invert match 反向显示, 匹配到的不显示，匹配不到的显示
							-E: 支持使用扩展的正则表达式元字符；
							-q: --quiet --silent 静默模式，不输出任何信息
								[root@localhost /]# grep "UUID" /etc/fstab
								UUID=b56040ad-21f1-48a2-859a-44867bfded62 /boot                   xfs     defaults        0 0
								[root@localhost /]# grep -q "UUID" /etc/fstab
								[root@localhost /]# echo $?
								0 							0表示匹配到了
								[root@localhost /]# grep -q "UUIiD" /etc/fstab
								[root@localhost /]# echo $?
								1							1表示没有匹配到
								
							-A#  after
							-B#  before
							-C#	 context
							[root@localhost /]# grep -A2 root /etc/passwd   显示文件能匹配到root文本的接下来的两行
							root:x:0:0:root:/root:/bin/bash
							bin:x:1:1:bin:/bin:/sbin/nologin
							daemon:x:2:2:daemon:/sbin:/sbin/nologin
							--
							operator:x:11:0:operator:/root:/sbin/nologin
							games:x:12:100:games:/usr/games:/sbin/nologin
							ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
	
							[root@localhost /]# grep -B2 root /etc/passwd   显示文件能匹配到root文本的前面两行
							root:x:0:0:root:/root:/bin/bash
							--
							halt:x:7:0:halt:/sbin:/sbin/halt
							mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
							operator:x:11:0:operator:/root:/sbin/nologin
							
							[root@localhost /]# grep -C2 root /etc/passwd    显示文件能匹配到root文本的前后两行 上下文
							root:x:0:0:root:/root:/bin/bash
							bin:x:1:1:bin:/bin:/sbin/nologin
							daemon:x:2:2:daemon:/sbin:/sbin/nologin
							--
							halt:x:7:0:halt:/sbin:/sbin/halt
							mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
							operator:x:11:0:operator:/root:/sbin/nologin
							games:x:12:100:games:/usr/games:/sbin/nologin
							ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
						
			基本正则表达式的元字符：
				字符匹配：
					. :匹配任意单个字符
					[] :匹配指定范围内的任意单个字符
					[^] :匹配指定范围外的任意单个字符
						[:digit:] 匹配数字
						[:lower:] 小写字母
						[:upper:] 大写字母
						[:alpha:] 字母
						[:alnum:] 字母和数字
						[:punct:] 标点符号
						[:space:] 空格
					例如：
					[root@localhost ~]# grep "r[[:alpha:]][[:alpha:]]t" /etc/passwd    匹配r和t中间有两个字母的规则
					root:x:0:0:root:/root:/bin/bash
					operator:x:11:0:operator:/root:/sbin/nologin
				匹配次数：用在要指定其出现的次数的字符的后面，用于限制其前面字符出现的次数；默认工作于贪婪模式；
					*: 匹配其前面的字符任意次，0,1多次
						例如：grep "x*y" 这里表示x可以出现任意次，包括不出现，以下情况都能匹配
							abxy
							aby
							xxxxxxxy
							yab
					.*: 匹配任意长度的任意字符
					\?: 匹配其前面的字符0次或1次；即其前面的字符是可有可无的；
					\+: 匹配其前面的字符1次或多次；即其前面的字符要出现至少1次；
					\{m\}: 精确匹配m次
					\{m,n\}: 匹配其前面的字符至少m次，至多n次
					\{0,n\}: 匹配其前面的字符至多n次
					\{m,\}: 匹配至少m次
				
				位置锚定：
					^: 行首锚定，用于模式的最左侧；grep "^root" /etc/passwd  查找以root开头的行
					$: 行尾锚定，用于模式的最右侧；grep "root$" /etc/passwd  查找以root结尾的行
					^PATTERN$: 用于PATTERN完全匹配整行；grep "^root$" /etc/passwd  查找整行是root的行
					^$: 空白行，空格不是空白
					^[[:space:]]*$: 表示空白行或者有空格的行，空格可以出现任意次，包括0次
					
					单词：非特殊字符组成的连续字符（字符串）都称为单词；
					\< 或 \b: 词首锚定，用于单词模式的左侧，例如 grep "\<root" /etc/passwd
					\> 或 \b: 词尾锚定，用于单词模式的右侧；
					\<PATTERN\>: 匹配完整单词
					[root@localhost ~]# grep "\<root" /etc/passwd   匹配以root开头的单词的行
					root:x:0:0:root:/root:/bin/bash
					operator:x:11:0:operator:/root:/sbin/nologin
					[root@localhost ~]# grep "root\>" /etc/passwd   匹配以root结尾的单词行
					root:x:0:0:root:/root:/bin/bash
					operator:x:11:0:operator:/root:/sbin/nologin
					chroot:x:3004:3004::/home/chroot:/bin/bash
					[root@localhost ~]# grep "\<root\>" /etc/passwd  匹配有root单词的行
					root:x:0:0:root:/root:/bin/bash
					operator:x:11:0:operator:/root:/sbin/nologin
				
				练习：
					1. 显示/etc/passwd文件中不以/bin/bash结尾的行；grep -v "/bin/bash$" /etc/passwd
					2. 找出/etc/passwd文件中两位数或三位数	 grep "\<[[:digit:]]\{2,3\}\>" /etc/passwd
					3. 找出/etc/rc.d/rc.sysinit或/etc/grub2.cfg文件中，以至少一个空白字符开头，且后面非空白字符的行；grep "^[[:space:]]\+[^[:space:]]" /etc/grub2.cfg
					4. 找出"netstat -tan"命令的结果中以'LISTEN'后跟0、1或多个空白字符结尾的行； netstat -tan | grep "LISTEN[[:space:]]*$"

			分组及引用
				\(\): 将一个或多个字符捆绑在一起，当作一个整体进行处理；
					\(xy\)*ab: xy作为一个整体，括号前面要有转义符，bash命令中括号有特殊意义；
				Note: 分组括号中的模式匹配到的内容会被正则表达式引擎自动记录于内部变量中，这些变量为：
					\1: 模式从左侧起，第一个左括号以及与之匹配的右括号之间的模式所匹配到的字符；
					\2: 
					\3:
					...
					
						he loves his lover
						he likes his lover
						she likes her liker
						she loves her liker
						~]# grep "\(l..e)\.*\1" lovers.txt
					后向引用：引用前面的分组括号中的模式所匹配到的字符；
			
			
	egrep:
		支持扩展的正则表达式，实现类似于grep文本过滤功能；grep -E
		egrep [OPTIONS] PATTERN [FILE...]
			选项：
				-i, -o, -v, -q, -A, -B, -C
				-G:支持基本正则表达式
			扩展正则表达式的元字符：
				字符匹配：
					.：任意单个字符
					[]：指定范围内的任意单个字符
					[^]：指定范围外的任意单个字符
				次数匹配：
					*: 0,1，任意次
					?：0，1，其前的字符是可有可无的
					+：其前字符至少1次
					{m}：其前的字符m次
					{m,n}：至少m,至多n
						{0,n}
						{m,}
				位置锚定
					^: 行首锚定
					$: 行尾锚定
					\<, \b: 词首锚定
					\>, \b: 词尾锚定
				分组及引用
					(): 分组；括号内的模式匹配到的字符会被记录于正则表达式引擎内部变量中；
					后向引用: \1, \2,...
				或:
					a|b: a或者b
						C|cat: C或cat
						(c|C)at: cat或Cat
						grep -E "\<[[:digit:]]{2,3}\>" /etc/passwd
						grep -E "\<[0-9]{2,3}\>" /etc/passwd
						egrep "\<[0-9]{2,3}\>" /etc/passwd
				练习：
					1. 找出/proc/meminfo文件中，所有大写或小写s开头的行；至少有三种实现方法；
						grep -E "^[sS]" /proc/meminfo
						grep -E "^(s|S)" /proc/meminfo
						grep -Ei "^s" /proc/meminfo
					2. 显示当前系统上root、centos或user1用户的相关信息；
						grep -E "^(root|centos|user1)" /etc/passwd
					3. 找出/etc/rc.d/init.d/functions文件中某单词后面跟一个小括号的行；
						grep -E "\<.+\>\(\)" /etc/rc.d/init.d/functions
					4. 使用echo命令输出一绝对路径，使用egrep取出基名；
						测试目录：/etc/rc.d/rc2.d
						pwd | grep -E "\/.*\/"   没有得出结果
						 pwd | grep -Eo "[^/]+/?$"   正确方法
					5. 找出ifconfig命令结果中的1-255之间的数值；
						ifconfig |egrep  "\<[1-9][0-9]?\>|\<1[0-9]{2}\>|\<2[0-4][0-9]\>|\<25[0-5]\>"
					6. 课外作业：找出ifconfig命令结果中的IP地址；
						ifconfig |egrep "(\<([0,1]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\>\.){3}\<([0,1]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\>"
					7. 添加用户bash,testbash, basher以及nologin(其shell为/sbin/nologin);而后找出/etc/passwd文件中用户名同shell名的行；
						[root@localhost ~]# adduser bash
						[root@localhost ~]# adduser testbash
						[root@localhost ~]# adduser basher
						[root@localhost ~]# adduser nologin -s /sbin/nologin
						[root@localhost ~]# egrep "^\<(.*?)\>.*\1$" /etc/passwd


							

	
		
							
							
								


				
								
						
						

		
				
				
			
		
				
				
				
				
				
				
				
				
				
				
				
				
			
			
			
			
			
			
			
			
			
			
			
			
		

